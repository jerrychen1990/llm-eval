{"question": "对于以下结构定义，++p->str中的++加在____\nstruct{\nint len;\nchar*str;\n}*P;", "answer": null, "options": {"A": "指针 p 上", "B": "指针 str 上", "C": "str 指的内容上", "D": "语法错误"}, "label": "ceval"}
{"question": "下面关于m阶B树说法正确的是____①每个结点至少有两棵非空子树②树中每个结点至多有m-1个关键字；③所有叶子在同一层上；④当插入一个数据项引起B树结点分裂后，树长高一层。", "answer": null, "options": {"A": "① ② ③", "B": "② ③", "C": "② ③ ④", "D": "③"}, "label": "ceval"}
{"question": "对于具有n个项点的图，若采用邻接矩阵表示，则该矩阵的大小为____。", "answer": null, "options": {"A": "n", "B": "n^2", "C": "n-1", "D": "(n-1)^2"}, "label": "ceval"}
{"question": "置换-选择排序的作用是：____", "answer": null, "options": {"A": "置换-选择排序是完成将一个磁盘文件排序成有序文件的有效的外排序算法", "B": "置换-选择排序生成的初始归并段长度是内存工作区的 2 倍", "C": "置换-选择排序用于生成外排序的初始归并段", "D": "置换-选择排序是对外排序中输入/归并/输出的并行处理"}, "label": "ceval"}
{"question": "以下说法不正确的是____", "answer": null, "options": {"A": "public继承中派生类的成员函数可以访问基类中的私有成员", "B": "private继承中派生类对象不允许向上转换", "C": "显式调用基类构造函数只能在派生类构造函数的初始化成员列表中进行", "D": "如果基类的某个构造函数被声明为私有，则不能在派生类中调用该私有构造函数"}, "label": "ceval"}
{"question": "以下时间复杂度，____不是O(Nlog_2N)", "answer": null, "options": {"A": "快速挂序的最坏情况", "B": "堆排序的平均情况", "C": "归并排序的最坏情况", "D": "归并排序的最好情况"}, "label": "ceval"}
{"question": "C++中，下列关于继承的描述，____是错误的。", "answer": null, "options": {"A": "继承是基于对象操作的层面而不是类设计的层面上的", "B": "子类可以继承父类的公共行为", "C": "继承是通过重用现有的类来构建新的类的一个过程", "D": "将相关的类组织起来，从而可以共享类中的共同的数据和操作"}, "label": "ceval"}
{"question": "一个顺序栈S,其栈顶指针为top,则将元素e入栈的操作是____。", "answer": null, "options": {"A": "*S->top=e;S->top++;", "B": "S->top++;*S->top=e;", "C": "*S->top=e;", "D": "S->top=e;"}, "label": "ceval"}
{"question": "假定在C++程序中有如下说明：\ndouble image[10][20];\n那么，下列c表达式会得到image数组的最后一个元素的地址？____", "answer": null, "options": {"A": "image[10][19]", "B": "image[10][20]", "C": "&image[9][19]", "D": "&image[10][19]"}, "label": "ceval"}
{"question": "在最坏情况下，二分查找算法的时间复杂度是____", "answer": null, "options": {"A": "O(1)", "B": "O(N)", "C": "O(log(N))", "D": "$O(N^2)$"}, "label": "ceval"}
{"question": "将长度为N的单链表链接在长度为M的单链表之后的算法的时间复杂度为____", "answer": null, "options": {"A": "O(1)", "B": "O(N)", "C": "O(M)", "D": "O(M+N)"}, "label": "ceval"}
{"question": "下列关于重载函数和虚函数的说法中，错误的是____", "answer": null, "options": {"A": "重载函数在类型和参数数量上一定不相同，而覆盖的虚函数则要求参数的类型和个数、函数返回类型相同。", "B": "只有类的成员函数可以是虚函数，重载函数既可以是成员函数之间重载，也可以是全局函数之间重载。", "C": "构造函数可以重载，但不能是虚函数。", "D": "析构函数不能作为虚函数。"}, "label": "ceval"}
{"question": "以下说法正确的是____", "answer": null, "options": {"A": "同一个运算符可以被重载多次；", "B": "C++已有的运算符都可以重载;", "C": "自增运算符重载时，重载函数不允许有输入参数；", "D": "运算符函数的返回类型不能声明为基本数据类型。"}, "label": "ceval"}
{"question": "下面程序段的时间复杂度是____。\nfor(i=0;i<m;i++)\nfor(j=0;j<n;j++)\na[i][j]=i*j;", "answer": null, "options": {"A": "O(m^2)", "B": "O(n^2)", "C": "O(m*n)", "D": "O(m+n)"}, "label": "ceval"}
{"question": "某二叉树有N个节点，高度为，在其中插入一个新的节点，高度发生改变的节点个数最多为____", "answer": null, "options": {"A": "O(1)", "B": "O(N)", "C": "O(h)", "D": "O(hlog_2N)"}, "label": "ceval"}
{"question": "对已十分接近按键值排序的初始序列，插入法、归并法和一般的快速分类法对其排序，算法的时间复杂度各为____。", "answer": null, "options": {"A": "O(N)，O(N)，O(N)", "B": "O(N)，O(Nlog_2N)，O(Nlog_2N)", "C": "O(N)，O(Nlog_2N) O(N^2)", "D": "O(N^2)，O(Nlog_2N)，O(N^2)"}, "label": "ceval"}
{"question": "分别按照下列序列构造二叉查找树，与用其它三个序列所构造的结果不同的是____", "answer": null, "options": {"A": "( 105, 84, 97， 63， 122, 118, 131 )", "B": "( 105, 122, 118, 131, 84, 63, 97 )", "C": "( 105, 63, 84, 97, 122, 118, 131 )", "D": "( 105, 84, 63, 97, 122, 131, 118 )"}, "label": "ceval"}
{"question": "以下代码能够通过编译的是____", "answer": null, "options": {"A": "class A {\npublic:\nA* a; \n};\nint main() {A a; return 0;}", "B": "class B {\npublic:\nB& b;\n};\nint main() {B b; return 0;}", "C": "class C {\npublic:\n\t\tC c;\n};\nint main() {C c; return 0;}", "D": "class E {};\nclass D {\n\tpublic:\n\t\t\tE& d;\n};\nint main() {D d; return 0;}"}, "label": "ceval"}
{"question": "在C++语言中，自定义的标识符____", "answer": null, "options": {"A": "能使用关键字并且不区分大小写", "B": "能使用关键字并且区分大小写", "C": "不能使用关键字并且不区分大小写", "D": "不能使用关键字并且区分大小写"}, "label": "ceval"}
{"question": "若以一个大小为6的数组来实现循环队列，当前的rear和front的位置分别为0和3，当依次执行：两次出队、两次入队、一次出队后，当前rear和front位置分别是____", "answer": null, "options": {"A": "5,1", "B": "2,5", "C": "2,0", "D": "4,0"}, "label": "ceval"}
{"question": "已知函数定义的形式如下：\nstruct data f(void)\n{…}\n则函数f____", "answer": null, "options": {"A": "没有参数，返回值是一个结构", "B": "有一个参数void,返回值是一个结构", "C": "没有参数，返回值是一个结构指针", "D": "有一个参数void,返回值是一个结构指针"}, "label": "ceval"}
{"question": "下列关于哈希查找的说法正确的是____", "answer": null, "options": {"A": "哈希函数构造得越复杂越好， 因为这样随机性好， 冲突小", "B": "除留余数法是所存哈希函数中最好的。", "C": "不存在特别好与坏的哈希函数， 视情况而定。", "D": "在哈希表中删除一个元素， 不管用何种方法解决冲突都只需简单地将该元素刪去即司"}, "label": "ceval"}
{"question": "快速构建适用于不同场景的程序框架____", "answer": null, "options": {"A": "行为型", "B": "结构型", "C": "组合型", "D": "创建型"}, "label": "ceval"}
{"question": "在常用的描述二叉查找树的存储结构中，关键字值最大的结点____。", "answer": null, "options": {"A": "左指针一定为空", "B": "右指针一定为空", "C": "左右指针均为空", "D": "左右指针均不为空"}, "label": "ceval"}
{"question": "在C语言中，下列表达式的值最大的是____", "answer": null, "options": {"A": "sizeof('a');", "B": "sizeof(97);", "C": "sizeof(\"aaaa\");", "D": "sizeof(97.0);"}, "label": "ceval"}
{"question": "对于一个具有n个顶点和e条边的无向图，进行拓扑排序时，总的时间为____", "answer": null, "options": {"A": "n", "B": "n+1", "C": "n-1", "D": "n+e"}, "label": "ceval"}
{"question": "C++语言建立类族是通过____", "answer": null, "options": {"A": "类的嵌套", "B": "类的继承", "C": "虚函数", "D": "抽象类"}, "label": "ceval"}
{"question": "对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是____", "answer": null, "options": {"A": "head==NULL", "B": "head->next=NULL", "C": "head->next==head", "D": "head!=NULL"}, "label": "ceval"}
{"question": "在public继承的情况下，派生类对象对基类中的public成员、protected成员和private成员的访问特性是____", "answer": null, "options": {"A": "只有 public 成员可以访问", "B": "只有 private 成员不可以访问", "C": "public 成员和 protected 成员可以访问", "D": "三种成员都可以访问"}, "label": "ceval"}
{"question": "在c++中，定义了以下的一个类\nclass example\n{\nprivate:\nint data;\npublic:\nint set(int param);\n};\n下列操作____是正确的", "answer": null, "options": {"A": "example object;\nobject.data=10;", "B": "example object;\ndata=object.set(10);", "C": "example object;\nobject.data=object.set(10)", "D": "example object;"}, "label": "ceval"}
{"question": "#include<iostream.h>\nclass One\n{\npublic:\nvoid display(){cout<<\"1\"<<\"\";}\n};\nclass Two:public One\n{\npublic:\nvoid display(){cout<<\"2\"<<\"\";}\n};\nvoid main()\n{\nOne first;\nTwo second;\nfirst.display();\nsecond.display();\nOne *p=&first;\np->display();\np=&second;\np->display();\n}在\nC++中，以上程序的运行结果为____。", "answer": null, "options": {"A": "1 1 1 2", "B": "1 2 1 2", "C": "1 2 1 1", "D": "2 1 1 2"}, "label": "ceval"}
{"question": "以下对模板方法和策略模式说法不正确的是：____", "answer": null, "options": {"A": "在设计思路上，模板方法模式优先考虑组合，策略模式优先考虑继承", "B": "使用模板方法可以定义抽象概念，拥有不同的实现", "C": "使用策略模式可以减小单一类承担的指责", "D": "使用模板方法和策略模式定义的抽象概念时，都直接使用接口类来引用这一概念"}, "label": "ceval"}
{"question": "一个文件中的全局变量，如果不允许其他的文件引用，则需要在声明时加上____关键词。", "answer": null, "options": {"A": "auto", "B": "register", "C": "extern", "D": "static"}, "label": "ceval"}
{"question": "时间复杂度不受数据初始状态影响而恒为O(Nlog_2N)的是____", "answer": null, "options": {"A": "堆排序", "B": "冒泡排序", "C": "希尔排序", "D": "快速排序"}, "label": "ceval"}
{"question": "下列语句正确的是____", "answer": null, "options": {"A": "char a[2]={a};", "B": "char 3a=\\0';", "C": "char a[]='abc';", "D": "char a= \"\\0\";"}, "label": "ceval"}
{"question": "有如下程序段，则以下选项中哪一项不可能导致it失效：\n\t#include<vector>\n\tusing namespace std;\n\tint main(){\n\t\tvector<int>vec;\n\t\t...\n\t\tauto it=vec.begin()+5;//假设此时vec的长度大于5\n\t\t...\n\t}____", "answer": null, "options": {"A": "vec.push_back(2);", "B": "vec.erase(vec.begin());", "C": "vec.insert(it, 2);", "D": "vec[5] = 2;"}, "label": "ceval"}
{"question": "以下说法正确的是____", "answer": null, "options": {"A": "在 二叉査找树中， 最大的元素一定存放在叶结点中", "B": "已知二叉树的前序遍历序列和后序遍历序列， 可以唯一确定这棵二叉树", "C": "若初始森林中共有 n 棵二叉树， 最终求得的哈夫曼树共有 2n+1 个结点", "D": "已知树的前序遍历序列和后序遍历序列, 可以唯一确定这棵树"}, "label": "ceval"}
{"question": "广义表((a),a)的表尾是____.", "answer": null, "options": {"A": "a", "B": "(a)", "C": "()", "D": "((a))"}, "label": "ceval"}
{"question": "若某线性表最常用的操作是读取第i个元素和第i个元素的前趋元素，则采用下面哪种存储方式最节省运算时间？____", "answer": null, "options": {"A": "单链表", "B": "顺序表", "C": "双链表", "D": "单循环链表"}, "label": "ceval"}
{"question": "下列说法是在描述适配器模式的是____", "answer": null, "options": {"A": "将一个类的接口转换成客户希望的另外一个接口。本模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作；", "B": "定义一个用于创建对象的接口，让子类决定实例化哪一个类；", "C": "表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作；", "D": "将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。"}, "label": "ceval"}
{"question": "下面关于虚函数的描述，错误的是____", "answer": null, "options": {"A": "在成员函数声明的前面加上 virtual 修饰，就可把该函数声明为虚函数", "B": "基类中说明了虚函数后，派生类中对应的函数也必须说明为虚函数", "C": "虚函数可以是另一个类的友元函数，但不能是静态成员函数", "D": "基类中说明的纯虚函数在其任何派生类中都必须实现"}, "label": "ceval"}
{"question": "正常情况下，删除非空的顺序存储结构的堆栈的栈项元素，栈顶指针top的变化是____。", "answer": null, "options": {"A": "top不变", "B": "top=0", "C": "top=top+1", "D": "top=top-1"}, "label": "ceval"}
{"question": "若类B是从类A派生而来，而语句p.Do();在被多次执行时，有的时候调用的是类A的Do成员函数，有的时候调用的是类B的Do成员函数，那么p的类型可以是____", "answer": null, "options": {"A": "A &", "B": "A *", "C": "B", "D": "A"}, "label": "ceval"}
{"question": "深度为5的二叉树其结点数最多为____", "answer": null, "options": {"A": "16", "B": "30", "C": "31", "D": "32"}, "label": "ceval"}
{"question": "下列关于图遍历的说法不正确的是____", "answer": null, "options": {"A": "连通图的深度优先搜索是一个递归过程", "B": "图的广度优先搜索中邻接点的寻找具有“ 先进先出” 的特征", "C": "非连通图不能用深度优先搜索法", "D": "图的遍历要求每一顶点仅被访问一次"}, "label": "ceval"}
{"question": "设有50000个待排序的记录关键字，如果需要用最快的方法选出其中最小的10个记录关键字，则用下列____方法可以达到此目的。", "answer": null, "options": {"A": "快速排序", "B": "选择排序", "C": "归并排序", "D": "插入排序"}, "label": "ceval"}
{"question": "以下说法正确的是____", "answer": null, "options": {"A": "派生类会继承基类的数据成员、函数成员和重载赋值运算符；", "B": "基类中没有指定访问说明符时，编译器将默认该说明符是public；", "C": "派生类不会继承基类的构造函数，因此不能用于创建派生类对象的基类部分；", "D": "派生类的构造函数可以调用特定的基类构造函数，间接访问基类的私有成员。"}, "label": "ceval"}
{"question": "以下关于迭代器模式的说法不正确的是：____", "answer": null, "options": {"A": "迭代器是对“数据访问”设计的接口", "B": "迭代器提供一种方法访问一个聚合对象中各个元素，而不用关心具体存储类的算法", "C": "迭代器模式中，编写上层代码时需要根据使用需求和性能需求同时使用迭代器和存储类的方法对存储的数据进行访问", "D": "迭代器类通常设计为存储类的友元，从而迭代器类可以访问存储类内部的数据"}, "label": "ceval"}
{"question": "在10阶B-树中根结点所包含的关键码个数最多为____", "answer": null, "options": {"A": "1", "B": "2", "C": "9", "D": "10"}, "label": "ceval"}
{"question": "字符指针和字符数组均可以作为C风格字符串首地址，但是二者是有区别的。观察以下程序\nint main(){\nchar*a=\"Hello\";\nchar b[]=\"World\";\ncout<<a[0]<<endl;//①\na[0]='h';//②\ncout<<b[0]<<endl;//③\nb[0]='w';//④\nreturn 0;\n}\n则下列说法正确的是____", "answer": null, "options": {"A": "程序无法通过编译", "B": "程序在执行到第②条语句会有运行错误", "C": "程序在执行到第④条语句会有运行错误", "D": "程序可以正常运行"}, "label": "ceval"}
{"question": "int a[4][5];则和a[3][2]的值等价的表达式为____", "answer": null, "options": {"A": "*(*a[3]+2)", "B": "*(a+17)", "C": "*((a+3)+2)", "D": "*(a[3]+2)"}, "label": "ceval"}
{"question": "静态链表中指针表示的是____", "answer": null, "options": {"A": "内存地址", "B": "数组下标", "C": "下一元素地址", "D": "左、右孩子地址"}, "label": "ceval"}
{"question": "下列关于类对象说法错误的是：____", "answer": null, "options": {"A": "函数静态对象，在程序执行到该局部静态对象的代码时被初始化；程序第二次执行到该对象代码时，不再初始化", "B": "在不同编译单元中，全局对象的初始化顺序不确定", "C": "当A类对象是B类的常量静态成员时，可以在B类内初始化", "D": "当A类对象是B类的静态非常量成员变量时，只能在B类外初始化"}, "label": "ceval"}
{"question": "设一组初始记录关键字序列为（25,50,15,35,80,85,20,40,36,70)，其中含有5个长度为2的有序子表，则用归并排序的方法对该记录关键字序列进行一趟归并后的结果为____", "answer": null, "options": {"A": "15， 25， 35， 50， 20， 40， 80， 85， 36， 70", "B": "15， 25， 35， 50， 80， 20， 85， 40， 70， 36", "C": "15， 25， 35， 50， 80， 85, 20， 36， 40, 70", "D": "15, 25, 35, 50, 80, 20, 36, 40, 70, 85"}, "label": "ceval"}
{"question": "若B知一个栈的入找序列是1,2,3,...,n.其输出序列为pi,p2.p3,…,pN,若pN是n,则pi是____", "answer": null, "options": {"A": "i", "B": "n-i", "C": "n-i+1", "D": "不确定"}, "label": "ceval"}
{"question": "稳定的排序方法是：____", "answer": null, "options": {"A": "直接插入排序和快速排序", "B": "二分插入排序和冒泡排序", "C": "直接选择排序和四路归并排序", "D": "堆排序和希尔排序"}, "label": "ceval"}
{"question": "如果class类中的所有成员在定义时都没有使用关键字pubilc,private,protected，则所有成员缺省定义为：____。", "answer": null, "options": {"A": "public", "B": "protected", "C": "private", "D": "static"}, "label": "ceval"}
{"question": "下列关于AOE网的叙述中，不正确的是____。", "answer": null, "options": {"A": "某些关键活动提前，则整个工程将会提前完成", "B": "任一关键活动提前，则整个工程将会提前完成", "C": "所有关键活动提前，则整个工程将会提前完成", "D": "关键活动不按期完成会影响整个工程的完成时间"}, "label": "ceval"}
{"question": "具有线性结构的数据结构是____。", "answer": null, "options": {"A": "图", "B": "树", "C": "广义表", "D": "栈"}, "label": "ceval"}
{"question": "设有一个递归算法如下\nint x(int n){\nif(n<=3)return 1;\nelse return x(n-2)+x(n-4)+1;}\n试问计算x(x(8))时需要计算____次x函数。", "answer": null, "options": {"A": "8次", "B": "9次", "C": "16次", "D": "18次"}, "label": "ceval"}
{"question": "静态成员函数不能说明为____。", "answer": null, "options": {"A": "整型函数", "B": "浮点函数", "C": "虚函数", "D": "字符型函数"}, "label": "ceval"}
{"question": "二叉查找树的查找效率与二叉树的____有关。", "answer": null, "options": {"A": "高度", "B": "结点的多少", "C": "树型", "D": "结点的位置"}, "label": "ceval"}
{"question": "广义表G=(a,b(c,d,(e,f)),g)的长度是____。", "answer": null, "options": {"A": "3", "B": "4", "C": "7", "D": "8"}, "label": "ceval"}
{"question": "当使用ifstream流类定义一个流对象并打开一个磁盘文件file时，与语句：ifstream infile; infile.open(\"file”)；等价的文件的打开方式为____", "answer": null, "options": {"A": "ofstream infile; infile.open(\"file\");", "B": "ifstream infile; infile.open(\"file\", ifstream::out );", "C": "ifstream infile(\"file\");", "D": "fstream infile; infile.open(\"file\");"}, "label": "ceval"}
{"question": "用函数H(k)=key%17构造散列表，则链地址法解决冲突需____个链表。", "answer": null, "options": {"A": "17", "B": "13", "C": "16", "D": "任意"}, "label": "ceval"}
{"question": "二叉树先序遍历x在y之前，后序遍历x在y之后，则x是y的____。", "answer": null, "options": {"A": "左兄弟", "B": "右兄弟", "C": "祖先", "D": "后裔"}, "label": "ceval"}
{"question": "依次在初始为空的队列中插入元素a,b,c,d以后，紧接若做了两次删除操作，此时的队头元素是____。", "answer": null, "options": {"A": "a", "B": "b", "C": "c", "D": "d"}, "label": "ceval"}
{"question": "五节车厢以编号1,2,3,4,5顺序进入铁路调度站（栈），可以得到____的编组。", "answer": null, "options": {"A": "3,4,5,1,2", "B": "2,4,1,3,5", "C": "3,5,4,2,1", "D": "1,3,5,2,4"}, "label": "ceval"}
{"question": "C++对C语言作了很多改进，下列描述中____使得C语言发生了质变，从面向过程变成了面向对象。", "answer": null, "options": {"A": "增加了一些新的运算符；", "B": "允许函数重载， 并允许设置缺省参数:", "C": "规定函数说明必须用原型；", "D": "弓I进了类和对象的概念；"}, "label": "ceval"}
{"question": "若有以下定义和语句，则不能合法表示a数组元素的是:____\nchar a[]=\"abcdefg\";\nint *p=a;", "answer": null, "options": {"A": "p[7]", "B": "a[p-a]", "C": "*a", "D": "a[8]"}, "label": "ceval"}
{"question": "若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用____存储方式最节省时间。", "answer": null, "options": {"A": "顺序表", "B": "双链表", "C": "带头结点的双循环链表", "D": "单循环链表"}, "label": "ceval"}
{"question": "一个图有30个结点，这些结点的平均度数为10，那么该图拥有多少条边？____", "answer": null, "options": {"A": "75", "B": "150", "C": "300", "D": "600"}, "label": "ceval"}
{"question": "下列不能作为类的成员的是____", "answer": null, "options": {"A": "自身类对象的指针", "B": "自身类对象", "C": "自身类对象的引用", "D": "另一个类的对象"}, "label": "ceval"}
{"question": "12个数据有序顺序存储，采用二分查找，查找失败时的ASL值是____。", "answer": null, "options": {"A": "13850", "B": "63/13", "C": "Dec-39", "D": "49/13"}, "label": "ceval"}
{"question": "在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的____倍。", "answer": null, "options": {"A": "1月2日", "B": "1", "C": "2", "D": "4"}, "label": "ceval"}
{"question": "设二叉树的先序遍历序列和后序遍历序列正好相反，则该二叉树满足的条件是____", "answer": null, "options": {"A": "空或只有一个结点", "B": "高度等于其结点数", "C": "任一结点无左孩子", "D": "任一结点无右孩子"}, "label": "ceval"}
{"question": "类Sample的拷贝构造函数的声明语句为____", "answer": null, "options": {"A": "Sample (Sample other)", "B": "Sample Sample (Sample other)", "C": "Sample (const Samplet &other)", "D": "Sample Sample (const Sample &other)"}, "label": "ceval"}
{"question": "在操作系统内部，函数调用是用下面哪种数据结构来实现的？____", "answer": null, "options": {"A": "线性表", "B": "队列", "C": "栈", "D": "树"}, "label": "ceval"}
{"question": "设给定权值总数有n个，其哈夫曼树的结点总数为____", "answer": null, "options": {"A": "不确定", "B": "2n", "C": "2n+1", "D": "2n-1"}, "label": "ceval"}
{"question": "以下关于工厂模式和抽象工厂模式说法正确的是：____", "answer": null, "options": {"A": "工厂方法的目的是构造单个类的对象", "B": "在工厂方法中，构造多个有特定组合方式的对象，应当为每一个组成成分单独设立工厂", "C": "工厂方法不能处理不同重载的构造函数", "D": "工厂模式中，对象的删除不可以交由用户负责"}, "label": "ceval"}
{"question": "关于纯虚函数和抽象类的描述中，错误的是____", "answer": null, "options": {"A": "抽象类只能作为基类使用， 其纯虚函数的实现由派生类给出", "B": "纯虚函数是一个特殊的虚函数， 它没有具体的实现", "C": "一个基类中说明有纯虚函数， 该基类的派生类一定不再是抽象类。", "D": "抽象类是指具有纯虚函数的类"}, "label": "ceval"}
{"question": "己知一个线性表中最常用的操作是删除第一个元素和在最后一个元素之后插入一个元素，则采用____存储方式最节省运算时间。", "answer": null, "options": {"A": "双链表", "B": "仅有头指针的单循环链表", "C": "单链表", "D": "仅有尾指针的单循环链表"}, "label": "ceval"}
{"question": "数组可以使用花括号进行初始化，则对于以下程序\nint main(){\nint a[10]={1,2,3,4};\nint b[10];\nreturn 0;\n}\n其中a[8]和b[8]的值为____", "answer": null, "options": {"A": "a[8]为 0， b[8]为随机值", "B": "二者均为 0", "C": "二者均为随机值", "D": "以上代码段不能通过编译"}, "label": "ceval"}
{"question": "将递归算法转换成对应的非递归算法时，通常需要使用____来保存中间结果。", "answer": null, "options": {"A": "队列", "B": "栈", "C": "链表", "D": "树"}, "label": "ceval"}
{"question": "以下关于复制构造函数的说法错误的是____", "answer": null, "options": {"A": "系统默认的复制构造函数实现的是深层复制", "B": "类成员有指针类型时，浅层复制存在着隐患", "C": "一个对象以值传递的方式传入函数时会调用复制构造函数", "D": "一个对象以值传递的方式作为函数返回值时会调用复制构造函数"}, "label": "ceval"}
{"question": "下列选项中，不能构成折半查找中关键字比较序列的是____", "answer": null, "options": {"A": "500， 200， 450， 180", "B": "500， 450， 200， 180", "C": "180， 500， 200， 450", "D": "180， 200， 500， 450"}, "label": "ceval"}
{"question": "#include<iostream.h>\nint& func(int&num)\n{\nnum++;\nreturn num;\n}\nvoid main()\n{\nint n1,n2=5;\nn1=func(n2);\ncout<<n1<<\"\"<<n2<<endl;\n}\n上面C++程序运行结果是____", "answer": null, "options": {"A": "56", "B": "65", "C": "66", "D": "55"}, "label": "ceval"}
{"question": "快速排序在下列哪种情况下最不利于发挥其长处____。", "answer": null, "options": {"A": "要排序的数据量很大", "B": "要排序的数据中含有多个相同值", "C": "要排序的数据个数为奇数", "D": "要排序的数据已基本有序"}, "label": "ceval"}
{"question": "对某二叉树进行先序遍历的结果为ABDEFC,中序遍历的结果为DBFEAC,则后序遍历的结果是____。", "answer": null, "options": {"A": "DBFEAC", "B": "DFEBCA", "C": "BDFECA", "D": "BDEFAC"}, "label": "ceval"}
{"question": "用某种排序方法对线性表{4,9,3,7,1,5,8,6,2}进行排序时，元素序列的变化情况如下：\n1）4,9,3,7,1,5,8,6,2\n2）2,1,3,4,7,5,8,6,9\n3）1,2,3,4,6,5,7,8,9\n4）1,2,3,4,5,6,7,8,9\n所采用的排序方法是____", "answer": null, "options": {"A": "插入排序", "B": "选择排序", "C": "快速排序", "D": "二路归并排序"}, "label": "ceval"}
{"question": "对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是____", "answer": null, "options": {"A": "98,22,91,24,94,71", "B": "92,18,90,34,86,35", "C": "23,89,77,29,36,38", "D": "10,25,71,68,33,34"}, "label": "ceval"}
{"question": "假定A是一个类的名字，下面哪个语句不会引发类A构造函数的调用____", "answer": null, "options": {"A": "A * p = new A;", "B": "A a;", "C": "A a[10];", "D": "A * a[10];"}, "label": "ceval"}
{"question": "classwheel\n{\nint num;\npublic:\nwheel(int w){num=w;}\n};\nclass car\n{\nwheel carWheel;\npublic:\n____//写出car的构造函数\n}在\nC++中，上面程序中，空白处正确的语句是____。", "answer": null, "options": {"A": "void car(int n)::carWheel(n){}", "B": "car(int n): carWheel(n){}", "C": "void car(int n):: carWheel(n){}", "D": "car(int n):: carWheel(n){}"}, "label": "ceval"}
{"question": "顺序存储的线性表，其长度为n。假设在任何位置上插入或删除操作都是等概率的。插入一个元素时平均要移动表中元素个数为____", "answer": null, "options": {"A": "n/2", "B": "(n+1)/2", "C": "(n-1)/2", "D": "n"}, "label": "ceval"}
{"question": "ch为char类型，判断ch为小写字符的表达式是____", "answer": null, "options": {"A": "a'<=ch<='z'", "B": "(ch>='a')&(ch<='z')", "C": "(ch>='a')&&(ch<='z')", "D": "(ch>='a')l(ch<='z')"}, "label": "ceval"}
{"question": "下列程序的运行结果为____\n#include<iostream.h>\nint i=0;\nclass A\n{\npublic:\nA(){i++;}\n};\nvoid main()\n{\nA a,b[3],*c;\nc=b;\ncout<<i<<endl;}", "answer": null, "options": {"A": "2", "B": "3", "C": "4", "D": "5"}, "label": "ceval"}
{"question": "#include<iostream.h>\nclass A\n{\npublic:\nA(){cout<<\"A construct\";}\n};\nclass B:public A\n{\npublic:\nB():A(){cout<<\"B construct\"<<endl;}\n};\nvoid main(){B obj;}\n上面的C++程序运行的结果是____。", "answer": null, "options": {"A": "B construct A construct", "B": "A construct B construct", "C": "A construct", "D": "B construct"}, "label": "ceval"}
{"question": "下列关于对象概念的描述中____是错误的", "answer": null, "options": {"A": "对象就是 C 语言中的结构变量", "B": "对象代表着正在创建的系统中的一个实体", "C": "对象是一个状态和操作（或方法）的封装体", "D": "对象之间的信息传递是通过消息进行的"}, "label": "ceval"}
{"question": "假定M为一个类，int a()为该类的一个成员函数，若该成员函数在类定义体外定义,则函数头为____", "answer": null, "options": {"A": "AA::a();", "B": "int AA:a();", "C": "int AA::a();", "D": "AA::int a() ;"}, "label": "ceval"}
{"question": "#include<iostream.h>\n#include<iomanip.h>\nvoid main()\n{\ncout.fill('*');\ncout.width(10);\ncout<<\"123.45\"<<endl;\ncout.width(8);\ncout<<\"1234.45\"<<endl;\ncout.width(4);\ncout<<\"1234.45\"<<endl;\n}\n程序运行的结果是____。", "answer": null, "options": {"A": "****123.45 **1234.45 *1234.45", "B": "****123.45 *1234.45 1234.45", "C": "****123.45 **1234.45 *1234.45", "D": "*****123.45 ***1234.45 *1234.45"}, "label": "ceval"}
{"question": "C++语言的跳转语句中，对于break和continue说法正确的是____", "answer": null, "options": {"A": "break语句只应用于循环体中", "B": "continue语句用于跳出循环语句", "C": "continue语句用于跳出当前的循环周期", "D": "break语句用于跳出当前的循环周期"}, "label": "ceval"}
{"question": "下面描述中正确的是____", "answer": null, "options": {"A": "virtual 可以用来声明虚函数", "B": "含有纯虚函数的类是不能用来创建对象的， 因为它是虚基类", "C": "即使基类的构造函数没有参数， 派生类也必须建立构造函数", "D": "静态数据成员可以通过成员初始化列表来初始化"}, "label": "ceval"}
{"question": "函数：void f(void)\n{int i=12,j;\nfor(j=0;j<20;j++)\ni++;}\n当f执行完退出后，i的值为____", "answer": null, "options": {"A": "12", "B": "32", "C": "29", "D": "无定义"}, "label": "ceval"}
{"question": "与后置++不同，前置++运算符在C++语法中可以连续对变量使用，即可以++(++a)，这也是在重载前置++运算符时需要返回引用的原因。那么观察以下计时器类Timer的定义\n#include<iostream>\nusing namespace std;\nclass Timer{\nprivate:\nint sec;\npublic:\nTimer(){\nsec=0;\n}\nTimer operator++(){//注意返回值不是引用\nsec++;\nreturn *this;\n}\nvoid show(){\ncout<<sec<<endl;\n}\n};\nint main(){\nTimer t;\n++(++(++t));//连续调用三次前置++\nt.show();\nreturn 0;\n}\n其中在重载前置++中，代码错误地没有返回Timer类的引用，那么下列说法正确的是____", "answer": null, "options": {"A": "程序无法通过编译", "B": "程序可以通过编译，程序仍然正确，输出 3", "C": "程序可以通过编译，程序逻辑错误，输出 0", "D": "程序可以通过编译，程序逻辑错误，输出 1"}, "label": "ceval"}
{"question": "哪个是类test的复制构造函数的合法原型？____", "answer": null, "options": {"A": "test::test()", "B": "test::test (test other)", "C": "test::test(const test &other)", "D": "void test::test(const test &other)"}, "label": "ceval"}
{"question": "有如下程序段：\n#include<iostream>\nusing namespace std;\nclass A{\npublic:\n\tvirtual void f(){cout<<\"A::f\"<<endl;}\n};\nclass B:publicA{\npublic:\n\tvoid f(){cout<<\"B::f\"<<endl;}\n};\nint main()\n{\n A *pa, a;\n B *pb, b;\n pa = &b;\n pb = static_cast<B*>(&a);\npa->f();\n pb->f();\n return 0;\n}\n执行上面的程序将输出（\\n表示换行）____", "answer": null, "options": {"A": "A::f\\nB::f\t\\n", "B": "B::f\\nA::f\\n", "C": "A::f\\nA::f\t\\n", "D": "B::f\\nB::f\\n"}, "label": "ceval"}
{"question": "灵活使用const关键字使程序的可读性和严谨性增强，观察如下程序\nint main(){\nint a=10;\nint b=20;\nconst int*p=&a;\nint* const q=&a;\n*p=15;//①\np=&b;//②\n*q=15;//③\nq=&b;//④:\nreturn 0;\n}\n其中会出现编译错误的语句是____", "answer": null, "options": {"A": "①和③", "B": "②和④", "C": "②和③", "D": "①和④"}, "label": "ceval"}
{"question": "一个栈的入栈序列为1,2,3,...,n，其出栈序列是p1,p2,p3,…,pn。若p2=3，则p3可能取值的个数是____", "answer": null, "options": {"A": "n-3", "B": "n-2", "C": "n-1", "D": "无法确定"}, "label": "ceval"}
{"question": "下面这段代码的运行结果为____(\\n表示换行)\n#include<iostream>\nusing namespace std;\nclass Base{\npublic:\nvirtual void foo(int){cout<<\"Base::foo(int)\"<<endl;}\n};\nclass Derived:public Base{\npublic:\nvoid foo(float){cout<<\"Derived::foo(float)\"<<endl;}\n};\nint main(){\nDerived d;\nBase *p=&d;\nd.foo(3,0);\np->foo(3,0);\n}", "answer": null, "options": {"A": "Base::foo(int)\\nBase::foo(int)\\n", "B": "Base::foo(int)\\nDerived::foo(float)\\n", "C": "Derived::foo(float)\\nBase::foo(int)\\n", "D": "Derived::foo(float)\\nDerived::foo(float)\\n"}, "label": "ceval"}
{"question": "继承的主要目的是____", "answer": null, "options": {"A": "增加数据成员", "B": "增加成员函数", "C": "实现函数的重载", "D": "实现代码重用"}, "label": "ceval"}
{"question": "有六个元素6，5，4，3，2，1的顺序进栈，问下列哪一个不是合法的出栈序列？____", "answer": null, "options": {"A": "5 4 3 6 1 2", "B": "4 5 3 1 2 6", "C": "3 4 6 5 2 1", "D": "2 3 4 1 5 6"}, "label": "ceval"}
{"question": "稀疏矩阵的常见压缩存储方法有____两种。", "answer": null, "options": {"A": "二维数组和三维数组", "B": "三元组和散列表", "C": "三元组和十字链表", "D": "散列表和十字链表"}, "label": "ceval"}
{"question": "在一个长度为的顺序表中，在第1个元素之前插入一个新元素时，需向后移动____个元素。", "answer": null, "options": {"A": "n-i", "B": "n-i+1", "C": "n-i-1", "D": "i"}, "label": "ceval"}
{"question": "建立派生类对象时,3种构造函数分别是a(基类的构造函数)、b(成员对象的构造函数)、c(派生类的构造函数)这3种构造函数的调用顺序为____", "answer": null, "options": {"A": "abc", "B": "acb", "C": "cab", "D": "cba"}, "label": "ceval"}
{"question": "下列描述中，不属于抽象类特性的是____", "answer": null, "options": {"A": "可以声明虚函数", "B": "可以重载构造函数", "C": "可以定义友元函数", "D": "可以定义其对象"}, "label": "ceval"}
{"question": "一个n个顶点的连通无向图，其边数至少为____。", "answer": null, "options": {"A": "n-1", "B": "n", "C": "n+1", "D": "n*logn"}, "label": "ceval"}
{"question": "下列说法错误的是____", "answer": null, "options": {"A": "公有继承的基类中的 public 成员在派生类中仍是 public 的", "B": "公有继承的基类中的 private 成员在派生类中仍是 private 的", "C": "私有继承的基类中的 public 成员在派生类中变成 private 的", "D": "保护继承的基类中的 public 成员在派生类中变成 protected 的"}, "label": "ceval"}
{"question": "对于线性表(7,34,55,25,64,46,20,10)进行做列存储时，若远用HK)=K%9作为散列函数，则散列地址为1的元素有____个。", "answer": null, "options": {"A": "1", "B": "2", "C": "3", "D": "4"}, "label": "ceval"}
{"question": "对于类模板Base,执行语句Base<int>object(2,3);后____", "answer": null, "options": {"A": "产生的模板类为 Base", "B": "产生的模板类为 object", "C": "产生的模板类为 Base<int>", "D": "直接定义了类模板的对象 object"}, "label": "ceval"}
{"question": "下面____可以判断出一个有向图中是否有环（回路）。", "answer": null, "options": {"A": "广度优先遍历", "B": "拓扑排序", "C": "求最短路径", "D": "求关键路径"}, "label": "ceval"}
{"question": "Dijkstra算法不适用于寻找以下____种图的最短路径。", "answer": null, "options": {"A": "所有边权重均为1的有向图", "B": "边的权重均为正数的有向图", "C": "边的权重均为正数的无向图", "D": "边的权重可能出现负数的有向图"}, "label": "ceval"}
{"question": "在二叉树结点的前序序列，中序序列和后序序列中，所有叶子结点的先后顺序____", "answer": null, "options": {"A": "完全相同", "B": "前序和中序相同，而与后序不同", "C": "都不相同", "D": "中序和后序相同，而与前序不同"}, "label": "ceval"}
{"question": "下面关于模板的描述，错误的是____", "answer": null, "options": {"A": "函数模板和类模板的参数可以是任意的数据类型", "B": "类模板不能直接使用，必须先实例化为相应的模板类．然后定义了模板类的对象后才能使用", "C": "函数模板不能直接使用，需要实例化为模板函数后才能使用", "D": "类模板的成员函数都是模板函数"}, "label": "ceval"}
{"question": "对于一棵M阶B+树，下列哪个选项是正确的？____", "answer": null, "options": {"A": "根节点一定有 2~M 个子节点", "B": "一个叶节点和一个非叶节点之间可以有相同的关键值", "C": "任意两个叶节点的深度不一定相同", "D": "所有的非叶节点都有M/2~M 个子节点"}, "label": "ceval"}
{"question": "类的成员函数中，不能为virtual函数的是____", "answer": null, "options": {"A": "static函数", "B": "const函数", "C": "析构函数", "D": "运算符重载函数"}, "label": "ceval"}
{"question": "如果>被重载成友元函数，则表达式objl>obj2被C++编译器解释为：____", "answer": null, "options": {"A": "operator>(obj1,obj2)", "B": ">(objl,obj2)", "C": "obj2.operator>(objl)", "D": "obj1.operator>(obj2)"}, "label": "ceval"}
{"question": "下面哪一种设计原则可以提高代码的可复用性和可维护性____", "answer": null, "options": {"A": "对继承开放，对重载关闭；", "B": "对重载开放，对继承关闭；", "C": "对修改开放，对扩展关闭；", "D": "对扩展开放，对修改关闭。"}, "label": "ceval"}
{"question": "深度为k的满二叉树若按自上而下，从左到右的顺序给结点进行编号（从1开始），则编号最小的叶子结点编号是____", "answer": null, "options": {"A": "2^(k-1)", "B": "2^(k-1)-1", "C": "2^(k-1)+1", "D": "2^k-1"}, "label": "ceval"}
{"question": "#include<iostream.h>\nclass A\n{\npublic:\nvirtual~A(){cout<<\"A\"<<\"\";}\n};\nclass B:public A\n{\n~B(){cout<<\"B\"<<\"\";}\n};\nvoid main()\n{\nA *pObj=new B;\ndelete pObj;\n}\n上面的C++程序的运行结果是____", "answer": null, "options": {"A": "A", "B": "B", "C": "A B", "D": "B A"}, "label": "ceval"}
{"question": "采用邻接表存储的图的广度优先遍历算法类似于二叉树的____", "answer": null, "options": {"A": "先序遍历；", "B": "中序遍历；", "C": "后序遍历", "D": "按层遍历"}, "label": "ceval"}
{"question": "定义析构函数时，应该注意____。", "answer": null, "options": {"A": "其名与类名完全相同", "B": "返回类型是 void 类型", "C": "无形参，也不可重载", "D": "函数体中必须有 delete 语句"}, "label": "ceval"}
{"question": "设int a=9,b=8,c=7,x=1;则执行语句 if(a>7)if(b>8)if(c>9)x=2;else x=3;后x的值是____", "answer": null, "options": {"A": "0", "B": "1", "C": "2", "D": "3"}, "label": "ceval"}
{"question": "设指针变量P指向单链表中结点A，若删除单链表中结点A,则需要修改指针的操作序列为____", "answer": null, "options": {"A": "q = p->next; p->data = q->data; p->next = q->next; free(q);", "B": "q = p->next; q->data = p->data;p->next=q->next; free(q);", "C": "q=p->next;p->next=q->next;free(q);", "D": "q=p->next;p->data=q->data;free(q);"}, "label": "ceval"}
{"question": "假定AB为一个类，则执行AB x；语句时将自动调用该类的____。", "answer": null, "options": {"A": "有参构造函数", "B": "无参构造函数", "C": "拷贝构造函数", "D": "赋值构造函数"}, "label": "ceval"}
{"question": "对顺序存储的线性表，设其长度为20,容量足够大。在任何位置上插入或删除操作都是等概率的。插入一个元素时平均要移动表中的____个元素", "answer": null, "options": {"A": "9.5", "B": "10", "C": "10.5", "D": "11"}, "label": "ceval"}
{"question": "类的友元函数能访问该类的____", "answer": null, "options": {"A": "私有成员", "B": "保护成员", "C": "所有成员", "D": "公有成员"}, "label": "ceval"}
{"question": "一个栈的输入序列为123…n，若输出序列的第一个元素是n，输出第i（1<=i<=n）个元素是____。", "answer": null, "options": {"A": "不确定", "B": "n-i+1", "C": "i", "D": "n-i"}, "label": "ceval"}
{"question": "设一组权值集合W={2,3,4,5,6}，则由该权值集合构造的哈夫曼树中带权路径长度之和为____", "answer": null, "options": {"A": "20", "B": "30", "C": "40", "D": "45"}, "label": "ceval"}
{"question": "系统中的文本显示类（TextView）和图片显示类（PictureView）都继承了组件类（Component），分别显示文本和图片内容，现需要构造带有滚动条或者带有黑色边框、或者既有滚动条又有黑色边框的文本显示控件和图片显示控件，但希望最多只增加三个类，____可以实现该目的。", "answer": null, "options": {"A": "代理模式", "B": "继承", "C": "策略模式", "D": "装饰模式"}, "label": "ceval"}
{"question": "队列的插入操作是在____。", "answer": null, "options": {"A": "队尾", "B": "队头", "C": "队列任意位置", "D": "队头元素后"}, "label": "ceval"}
{"question": "下列关于getline()和read()函数的叙述中，错误的是____", "answer": null, "options": {"A": "都可用于从键盘或文件读取字符串", "B": "getline()读取字符串长度是受限制的", "C": "read()读取字节数是受限制的", "D": "getline()终止符默认是换行符，也可以指定其他终止符"}, "label": "ceval"}
{"question": "以下哪个不是使用设计模式进行编程的特点____", "answer": null, "options": {"A": "牺牲了代码维护的代价，降低模型复杂程度", "B": "不优先使用继承", "C": "指导经验不足的程序员灵活运用面向对象的特性", "D": "快速构建适用于不同场景的程序框架"}, "label": "ceval"}
{"question": "从表中任一结点出发，都能扫描整个表的是____。", "answer": null, "options": {"A": "单链表", "B": "顺序表", "C": "循环链表", "D": "静态链表"}, "label": "ceval"}
{"question": "设广义表L=((a,b,c)),则L的长度和深度分别为____", "answer": null, "options": {"A": "1和1", "B": "1和3", "C": "1和2", "D": "2和3"}, "label": "ceval"}
{"question": "下面____是死循环。", "answer": null, "options": {"A": "for(i=0;i<10;i++) cout<<i<<\" \";", "B": "for(i=10;i>=1;i--) cout<<i<<\" \";", "C": "i=10;do cout<<i--<<\" \";while(i>0);", "D": "i=0;while(i<=10);cout<<++i<<\" \";"}, "label": "ceval"}
{"question": "在最大化堆中，不正确的是____", "answer": null, "options": {"A": "任何节点的数值不超过其父亲", "B": "兄弟节点之间具有确定的大小关系", "C": "节点的数值不超过其任何一个祖先", "D": "整个堆中的最大元素在根节点"}, "label": "ceval"}
{"question": "若C1是一个抽象类，下列语句中错误的是____", "answer": null, "options": {"A": "C1 *pC;", "B": "void fun(C1 arg);", "C": "void fun(C1 *arg);", "D": "void fun(C1 &arg);"}, "label": "ceval"}
{"question": "关键路径是事件结点网络中____。", "answer": null, "options": {"A": "从源点到汇点的最长路径", "B": "从源点到汇点的最短路径", "C": "最长的回路", "D": "最短的回路"}, "label": "ceval"}
{"question": "若一个图的边集为{<1,2>，<1,4>，<2,5>，<3,1>，<3,5>，<4,3>}，则从顶点1开始对该图进行深度优先搜索，得到的顶点序列可能为____", "answer": null, "options": {"A": "1,2,5,4,3", "B": "1,2,3,4,5", "C": "1,2,5,3,4", "D": "1,4,3,2,5"}, "label": "ceval"}
{"question": "线性表既可以用带头结点的链表表示，也可以用不带头结点的链表表示，前者最主要的好处是____。", "answer": null, "options": {"A": "使空表和非空表的处理统一", "B": "可以加快对表的遍历", "C": "节省存储空间", "D": "可以提高存取表元素的速度"}, "label": "ceval"}
{"question": "在以下运算符中，优先级最低的是____", "answer": null, "options": {"A": "!", "B": ">=", "C": "*", "D": "||"}, "label": "ceval"}
{"question": "对于下面定义的类\nclass Base {\nprotected: int x;\npublic: Base(int val = 1) { x = val; }\nvirtual void disp(){cout<< x<< endl; }\nvoid print() {cout<<x<< endl; }\n};\nclass Derived: public Base { int y;\npublic:\nDerived(int vail = 0, int val2 = 0): Base(vall) { y = val2; }\nvoid disp(){ cout<< \"x=\"<< x<< \" y=\"<< y<< endl; }\nvoid print() { cout<<\"x=\"<<x<<\" y=\"<< y<< endl; }\n};\n有定义Derived dd(3,4);\nBase *bp=&dd,bb=dd;\n则dd.disp()执行的是____", "answer": null, "options": {"A": "派生类的 disp 函数", "B": "派生类的 pririt 函数", "C": "基类的 disp 函数", "D": "基类的 print 函数"}, "label": "ceval"}
{"question": "下面有关重载函数的说法中正确的是____", "answer": null, "options": {"A": "重载函数必须具有不同的返回值类型；", "B": "重载函数形参个数必须相同", "C": "重载函数必须有不同的形参列表；", "D": "重载函数名可以不同；"}, "label": "ceval"}
{"question": "在快速排序过程中，下列结论正确的是____。", "answer": null, "options": {"A": "左、右两个子表都已各自排好序", "B": "左边的元素都不大于右边的元素", "C": "左边子表长度小于右边子表长度", "D": "左、右两边元素的平均值相等"}, "label": "ceval"}
{"question": "公有成员提供了类对外部的接口，私有成员是类的内部实现，而____不许外界访问,但允许派生类的成员访问，这样既有一定的隐藏能力，也提供了开放的接口。", "answer": null, "options": {"A": "私有成员", "B": "私有成员函数", "C": "保护成员", "D": "公有成员"}, "label": "ceval"}
{"question": "链表不具有的特点是____", "answer": null, "options": {"A": "插入、删除不需要移动元素", "B": "可随机访问任一元素", "C": "不必事先估计存储空间", "D": "所需空间与线性长度成正比"}, "label": "ceval"}
{"question": "在派生类中重新定义虚函数时，除了____方面,其他方面都必须与基类中相应的虚函数保持一致。", "answer": null, "options": {"A": "参数个数和类型", "B": "函数体", "C": "函数名称", "D": "返回类型"}, "label": "ceval"}
{"question": "对二叉树T中的某个结点x，它在先根序列、中根序列、后根序列中的序号分别为pre（x），in（x）、post（x），a和b是T中的任意两个结点，下列选项一定错误的是____。", "answer": null, "options": {"A": "a 是 b 的后代且 pre（a）<pre（b）", "B": "a 是 b 的祖先且 post（a）>post（b）", "C": "a 是 b 的后代且 in（a）<in（b）", "D": "a 在 b 的左边且 in（a）<in（b）"}, "label": "ceval"}
{"question": "当图中各条边的权值____时，广度优先搜索算法可用来解决单源最短路径问题。", "answer": null, "options": {"A": "不一定相等", "B": "均互不相等", "C": "均相等", "D": "对权值无特别要求"}, "label": "ceval"}
{"question": "对友元(friend)不正确的描述是____", "answer": null, "options": {"A": "友元关系既不对称也不传递。", "B": "友元声明可以出现在 private 部分， 也可以山现在 public 部分", "C": "整个类都可以声明为另一个类的友元。", "D": "类的友元函数必须在类的作WJ 域以外被定义。"}, "label": "ceval"}
{"question": "在有向图的逆邻接表中，每个顶点邻接表链接着该顶点所有____邻接点。", "answer": null, "options": {"A": "入边", "B": "出边", "C": "入边和出边", "D": "不是出边也不是入边"}, "label": "ceval"}
{"question": "对于如下定义的两个类模板，____中的模板实例化是无效的。Template<classT,int size> classArray{/**/} template<int hi,int wid>classScreen{/*…*/}", "answer": null, "options": {"A": "const int hi = 40; const int wi = 80; Screen <hi, wi + 32> Sobj;", "B": "const int arr_size = 1024; Array<string, arr_size> al;", "C": "double db = 3.1415; Array <double,db> a3;", "D": "Array <double,12> a3;"}, "label": "ceval"}
{"question": "判断一个有向图中是否存在回路，下列选项中两种算法均可行的是____", "answer": null, "options": {"A": "Dijkstra算法和深度优先遍历算法", "B": "深度优先遍历算法和拓扑排序方法", "C": "拓扑排序方法和Kruskal算法", "D": "Kruskal算法和Floyd算法"}, "label": "ceval"}
{"question": "请问下面的代码的输出是____\n#include<iostream>\nusing namespace std;\nclass A{\n\t\tpublic:\n\t\t\tvoid work(){cout<<\"A\";}\n};\nclass B:public A{\n\t\tpublic:\n\t\t\tvoid work(){cout<<\"B\";}\n};\nint main(){\n\t\tB*c=newB();\n\t\tA*d=newB();\n\t\tc->work();\n\t\td->work();\n}", "answer": null, "options": {"A": "AA", "B": "AB", "C": "BA", "D": "BB"}, "label": "ceval"}
{"question": "C++类体系中，不能被派生类继承的有____。", "answer": null, "options": {"A": "转换函数", "B": "构造函数", "C": "虚函数", "D": "静态成员函数"}, "label": "ceval"}
{"question": "class Employee\n{\nprivate:\nint a;\nprotected:\nint b;\npublic:\nint c;\nvoid display();\n};\nclass Director:public Employee\n{\npublic:\nvoid show();\n};\n在C++中，以下操作正确的是____。", "answer": null, "options": {"A": "void Employee::show(){cout<<a<<b<<c<<endl;}", "B": "void Director::display(){cout<<a<<b<<c<<endl;}", "C": "void Director::show(){cout<<a<<b<<c<<endl;}", "D": "void Director::show(){cout<<b<<c<<endl;};"}, "label": "ceval"}
{"question": "当使用fstream流类定义一个流对象并打开一个磁盘文件时,文件的隐含打开方式为____", "answer": null, "options": {"A": "ios::in", "B": "ios::out", "C": "fstream::in| fstream::out", "D": "没有指定打开方式"}, "label": "ceval"}
{"question": "以下说法不正确的是____", "answer": null, "options": {"A": "sum为自定义类的一个变量，可以通过 sum.operator()(5, 6);去调用()运算符重载函数", "B": "通过重载[]运算符: int operator[] (const char* name);使得我们可以像map一样使用 beijing[\"mon\"] = -3;", "C": "ClassName& operator++();为前缀自增运算符的重载声明", "D": "运算符()必须作为成员函数重载"}, "label": "ceval"}
{"question": "设有关键字初始序列{Q,H,C,Y,P,A,M,S,R,D,F,X}，新序列（F,H,C,D,P,A,M,Q,R,S,Y,X}是采用____方法对初始序列进行第一趟扫描的结果。", "answer": null, "options": {"A": "直接插入排序", "B": "二路归并排序", "C": "以第一元素为标准元素的快速排序", "D": "冒泡排序"}, "label": "ceval"}
{"question": "二叉树在线索化后，仍不能有效求解的问题是____。", "answer": null, "options": {"A": "前序线索二叉树中求前序后继", "B": "中序线索二叉树中求中序后继", "C": "中序线索二叉树中求中序前驱", "D": "后序线索二叉树中求后序后继"}, "label": "ceval"}
{"question": "若将n个顶点e条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是____", "answer": null, "options": {"A": "O(n)", "B": "O(n+e)", "C": "O(n^2)", "D": "O(ne)"}, "label": "ceval"}
{"question": "在具有n个结点的单链表上查找值为x的元素时，其时间复朵度为____。", "answer": null, "options": {"A": "O(n)", "B": "O(1)", "C": "O(n^2)", "D": "O(n-1)"}, "label": "ceval"}
{"question": "如果从无向图的任一顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是____", "answer": null, "options": {"A": "完全图", "B": "连通图", "C": "有回路", "D": "一棵树"}, "label": "ceval"}
{"question": "下面几个符号串编码集合中，不是前缀编码的是____。", "answer": null, "options": {"A": "{0,10,110,1111}", "B": "{11,10,001,101,0001}", "C": "{00,010,0110,1000}", "D": "{b,c,aa,ac,aba,abb,abc}"}, "label": "ceval"}
{"question": "下面关于静态数据成员的描述中，正确的是____", "answer": null, "options": {"A": "静态数据成员可以直接用类名调用", "B": "静态数据成员可以在类体内进行初始化", "C": "静态数据成员不能受 private 控制符的作用", "D": "类的不同对象有不同的静态数据成员值"}, "label": "ceval"}
{"question": "设森林中有三棵树，第一、第二和第三颗树中的结点个数分别为m1、m2和m3。那么在由该森林转化成的二叉树中根结点的右子树上有____个结点。", "answer": null, "options": {"A": "m1+m2", "B": "m2+m3", "C": "m1+m3", "D": "m1+m2+m3"}, "label": "ceval"}
{"question": "下列专门用于读取单个字符的是____", "answer": null, "options": {"A": "cin.read()", "B": "cin.get()", "C": "cin.put()", "D": "cin.getline()"}, "label": "ceval"}
{"question": "任一个有向图的拓扑序列____。", "answer": null, "options": {"A": "不存在", "B": "有一个", "C": "一定有多个", "D": "有一个或多个"}, "label": "ceval"}
{"question": "若char p[20]=”helloworld”;则输出该字符串正确的语句是____", "answer": null, "options": {"A": "cout<<p[20];", "B": "cout<<&p;", "C": "cout<<*p;", "D": "cout<< P;"}, "label": "ceval"}
{"question": "分析下面的C++代码段：\nclass Employee\n{\nprivate:\nint a;\nprotected:\nint b;\npublic:\nint c;\n};\nclass Director:public Employee{};\n在main()中，下列____操作是正确的。", "answer": null, "options": {"A": "Employee obj;\nobj.b=1;", "B": "Director boj;\nobj.b=10;", "C": "Employee obj;\nobj.c=3;", "D": "Director obj;\nobj.a=20;"}, "label": "ceval"}
{"question": "下列关于虚函数的描述中，正确的是____", "answer": null, "options": {"A": "派生类中要覆盖基类的虚函数， 必须使用 virtual", "B": "静态函数不得声明为虚函数", "C": "虚函数不得声明为另一个类的友元函数", "D": "派生类必须-覆盖基类的虚函数"}, "label": "ceval"}
{"question": "下列选项给出的是从根分别到达两个叶结点路径上的权值序列,能属于同一棵哈夫曼树的是____", "answer": null, "options": {"A": "24， 10， 5 和 24， 10， 7", "B": "24， 10， 5 和 24， 12， 7", "C": "24， 10， 10 和 24， 14， 11", "D": "24， 10， 5 和 24， 14， 6"}, "label": "ceval"}
{"question": "非递归后序遍历二叉树时，考察栈中的数据：若当前结点为x,且x没有右儿子，这时栈顶的结点为y,且它的TimesPop值为2.则栈顶结点y必是x的____", "answer": null, "options": {"A": "前序的后件", "B": "中序的后件", "C": "后序的前件", "D": "后序的后件"}, "label": "ceval"}
{"question": "下列对派生类的描述中错误的是____", "answer": null, "options": {"A": "基类中成员访问权限继承到派生类中都保持不变", "B": ".派生类至少有一个基类。", "C": "一个派生类可以作为另一个派生类的基类。", "D": "派生类的成员除了自己定义的成员外， 还包含了它的基类成员。"}, "label": "ceval"}
{"question": "在函数明中，____是不必要的", "answer": null, "options": {"A": "形式参数的类型", "B": "形式参数名", "C": "函数的返回类型", "D": "函数名"}, "label": "ceval"}
{"question": "关于重载运算符，下列说法正确的是____", "answer": null, "options": {"A": "同一个运算符不可以被重载多次；", "B": "C++已有的运算符都可以重载;", "C": "运算符重载函数只能作为类的成员函数;", "D": "运算符函数的返回类型可以声明为基本数据类型。"}, "label": "ceval"}
{"question": "要输出整形二维数组inta[5][5]中第i行第j列的元素，则对以下三条语句，\ncout<<a[i][j]<<endl;//①\ncout<<*(*(a+i)+j)<<endl;//②\ncout<<*(*a+i*5+j)<<endl;//③\n说法正确的是____", "answer": null, "options": {"A": "语句①有错误", "B": "语句②有错误", "C": "语句③有错误", "D": "语句①②③都是正确的"}, "label": "ceval"}
{"question": "以下说法不正确的是____", "answer": null, "options": {"A": "被声明为友元的函数或类，具有对出具友元声明的类的一切成员有访问权限。", "B": "A函数是B类的友元函数，B类是C类的友元类，A函数对C类没有特殊访问权限", "C": "编译器认为某个函数不值得内联，就会忽略内联修饰符", "D": "编译期间建立虚函数表VTABLE和虚函数指针VPTR"}, "label": "ceval"}
{"question": "若有以下说明：\nint a[10]={1,2,3,4,5,6,7,8,9,10},*p=a;\n则对数组元素地址的正确表示是____", "answer": null, "options": {"A": "&(a+1)", "B": "a++", "C": "&p", "D": "a+1"}, "label": "ceval"}
{"question": "用邻接表来存储图，则常见的操作的算法复杂度____。", "answer": null, "options": {"A": "与图的结点数和边数都有关", "B": "只与图的边数有关", "C": "只与图的结点数有关", "D": "与结点数和边数都无关"}, "label": "ceval"}
{"question": "顺序搜索算法适合于存储结构为____的线性表。", "answer": null, "options": {"A": "散列存储", "B": "顺序存储或链接存储", "C": "压缩存储", "D": "索引存储"}, "label": "ceval"}
{"question": "读下面C++程序：\n#include<iostream.h>\nclass line\n{\npublic:\nint color;\n};\nint startx;\nclass box\n{\nprivate:\nint upx,upy;\nint lowx,lowy;\npublic:\nint color;\nint same_color(line a,box b);\nvoid set_color(int c)\n{\ncolor=c;\n}\nvoid define_line(int x,int y)\n{\nstartx=x;\n}\n};\nint (在此添入答案)same_color(linea,boxb)\n{\nif(a.color==b.color)\nreturn 1;\nreturn 0;\n}\n在括号中添入____,该程序才能正常运行.", "answer": null, "options": {"A": "line::", "B": "box::", "C": "line->", "D": "box->"}, "label": "ceval"}
{"question": "在循环单链表中，head指向头结点，设P为指向结点的指针，则判断P为尾结点的条件____", "answer": null, "options": {"A": "P==NULL", "B": "P->next==NULL", "C": "P->next==head", "D": "p==head"}, "label": "ceval"}
{"question": "下面____方法可以判断出一个有向图中是否有环（回路）？", "answer": null, "options": {"A": "深度优先遍历", "B": "求最短路径", "C": "拓朴排序", "D": "求关键路径"}, "label": "ceval"}
{"question": "以下程序经过编译连接后的可执行文件名是How.exe，执行Howareyou!<回车>，输出结果是int main(int argc,char*argv[])\n{int len=0;\nprintf(\"%c\",*(*(argv+1)+1)+1);\nwhile(--argc>0) len+=strlen(argv[argc]);\nprintf(“%d,\"len);\n}____", "answer": null, "options": {"A": "s,5", "B": "s,7", "C": "w,5", "D": "w,7"}, "label": "ceval"}
{"question": "阅读以下程序：\n#include<iostream>\nusing namespace std;\nclass Base{\npublic:\nvoid fun(){cout<<\"Base::fun\"<<endl;}\n};\nclass Derived:public Base{\npublic:\nvoid fun(){cout<<\"Derived::fun\"<<endl;}\n};\nint main(int argc,const char *argv[]){\nBase a,*pb;\nDerived b;\n;\npb->fun();\nreturn 0;\n}\n要使以上程序的输出为“Base::fun”，横线上可以填的语句为____", "answer": null, "options": {"A": "pb=a", "B": "pb=b", "C": "pb=&b", "D": "pb=&Base"}, "label": "ceval"}
{"question": "图的广度优先队列遍历算法中使用队列作为其辅助数据结构，那么在算法执行过程中每个结点最多进队____。", "answer": null, "options": {"A": "1 次", "B": "2 次", "C": "3 次", "D": "4 次"}, "label": "ceval"}
{"question": "如果基类A和A的派生类B中都有成员函数func()；要在派生类的func()中调用同名的基类的func()成员函数，下列____操作下正确的。", "answer": null, "options": {"A": "func();", "B": "A::func();", "C": "B::func();", "D": "A.func();"}, "label": "ceval"}
{"question": "下列关键字序列中____是最大堆。", "answer": null, "options": {"A": "94,23,31,12,16,13", "B": "16,72,31,23,94,53", "C": "16,23,53,31,94,72", "D": "16,53,23,94,31,72"}, "label": "ceval"}
{"question": "#include<iostream.h>\nclass example\n{\nprivate:\nstatic int num;\npublic:\nexample(){num++;cout<<num<<\"\";}\n~example(){num--;cout<<num<<\"\";}\n};\nint example::num=1;\nvoid main()\n{\nexample object1;\nexample object2;\n}\n上面c++程序的输出结果是____。", "answer": null, "options": {"A": "1 1 1 1", "B": "2 1 2 1", "C": "2 2 3 2", "D": "2 3 2 1"}, "label": "ceval"}
{"question": "某二叉树的前序和后序序列正好相反，则该二叉树一定是____的二叉树。", "answer": null, "options": {"A": "空或只有一个结点", "B": "高度等于其结点数", "C": "任一结点无左孩子", "D": "任一结点无右孩子"}, "label": "ceval"}
{"question": "下面对静态数据成员的描述中，正确的是____", "answer": null, "options": {"A": "静态数据成员是类的所有对象共享的数据", "B": "类的每个对象都有自己的静态数据成员", "C": "类的不同对象有不同的静态数据成员值", "D": "静态数据成员不能通过类的对象调用"}, "label": "ceval"}
{"question": "假定对元素序列(7,3,5,9,1,12)进行堆排序，并且采用小根堆，则由初始数据构成的初始堆为____", "answer": null, "options": {"A": "1,3,5,7,9,12", "B": "1,3,5,9,7,12", "C": "1,5,3,7,9,12", "D": "1,5,3,9,12,7"}, "label": "ceval"}
{"question": "计算机中的算法指的是解决某一个问题的有限运算序列，它必须具备输入、输出、____等5个特性。", "answer": null, "options": {"A": "可执行性、可移植性和可扩充性", "B": "可执行性、有穷性和确定性", "C": "确定性、有穷性和稳定性", "D": "易读性、稳定性和确定性"}, "label": "ceval"}
{"question": "在一株高度为2的5阶B树中，根结点所含关键字的个数最少是____", "answer": null, "options": {"A": "5", "B": "7", "C": "8", "D": "1"}, "label": "ceval"}
{"question": "设有两个串S1和S2,求串S2在S1中首次出现位置的运算称作____。", "answer": null, "options": {"A": "连接", "B": "求子串", "C": "模式匹配", "D": "判断子串"}, "label": "ceval"}
{"question": "用哈希（散列）方法处理冲突（碰撞）时可能出现堆积（聚集）现象，下列选项中，会受堆积现象直接影响的是____", "answer": null, "options": {"A": "存储效率", "B": "散列函数", "C": "装填(装载)因子", "D": "平均查找长度"}, "label": "ceval"}
{"question": "下面关于线性表的叙述中，错误的是哪一个？____", "answer": null, "options": {"A": "线性表采用顺序存储，必须占用一片连续的存储单元。", "B": "线性表采用顺序存储，便于进行插入和删除操作。", "C": "线性表采用链接存储，不必占用一片连续的存储单元。", "D": "线性表采用链接存储，便于插入和删除操作。"}, "label": "ceval"}
{"question": "已知程序如下：\nint S(int n)\n{return(n<=0)?0:s(n-1)+n;}\nvoid main()\n{cout<<S(1);}\n程序运行时使用栈来保存调用过程的信息，自栈底到栈顶保存的信息依次对应的是____", "answer": null, "options": {"A": "main( )→S(1)→S(0)", "B": "S(0)→S(1)→main()", "C": "main( )→S(0)→S(1)", "D": "S(1)→S(0)→main( )"}, "label": "ceval"}
{"question": "对类的构造函数和析构函数描述正确的是____", "answer": null, "options": {"A": "构造函数可以重载， 析构函数不能重载", "B": "构造函数不能重载， 析构函数可以重载", "C": "构造函数可以重载， 析构函数也能重载", "D": "构造函数不能重载， 析构函数也不能重载"}, "label": "ceval"}
{"question": "以下类定义不能通过编译的是____", "answer": null, "options": {"A": "class A {\n\tpublic:\n\t\t\tvoid func(int a,int b) {}; \n};", "B": "class B {\n\tpublic:\n\t\t\tvoid func(int a,int b=1){}\n};", "C": "class C {\n\t\tpublic:\n\t\t\tvoid func(int a=3,int b){}\n};", "D": "class D {\npublic:\nvoid func(int a=3,int b=1){}\n};"}, "label": "ceval"}
{"question": "数据的逻辑结构可以分为____。", "answer": null, "options": {"A": "静态结构和动态结构", "B": "物理结构和存储结构", "C": "线性结构和非线性结构", "D": "虚拟结构和抽象结构"}, "label": "ceval"}
{"question": "若二叉树的前序序列和后序序列正好相反，则该二叉树一定是____的二叉树。", "answer": null, "options": {"A": "空或只有一个结点", "B": "任一结点无左子树", "C": "任一结点无右子树", "D": "高度等于其结点数"}, "label": "ceval"}
{"question": "空串和空格串____。", "answer": null, "options": {"A": "相同", "B": "不相同", "C": "可能相同", "D": "无法确定"}, "label": "ceval"}
{"question": "以下关于装饰模式和代理模式说法错误的是：____", "answer": null, "options": {"A": "可以把“装饰”看成是一连串的“代理”。", "B": "在对类进行装饰时，被装饰对象增加的行为通常重新实现原有功能。", "C": "代理模式中少见多重嵌套。", "D": "装饰模式通过对象的组合修改对象的功能。"}, "label": "ceval"}
{"question": "当输入为”12345c6”后敲回车键，下列函数的输出为：____\n#include<iostream>\nusing namespace std;\nint main(){\nint i=0,a=0;\nwhile(cin>>a){\ncout<<a;\n++i;\n}\ncout<<\"*\"<<i;\nreturn 0;\n}", "answer": null, "options": {"A": "1234*2", "B": "12 34 5*1", "C": "12345*3", "D": "12 34 *4"}, "label": "ceval"}
{"question": "下列叙述错误的是____", "answer": null, "options": {"A": "派生类一般都用公有派生；", "B": "对基类成员的访问必须是无二义性的；", "C": "基类的公有成员在派生类中仍然是公有的;", "D": "赋值兼容规则也适用于多重继承的组合。"}, "label": "ceval"}
{"question": "C++基类中的private成员通过____类型的继承，可以被派生类访问。", "answer": null, "options": {"A": "public", "B": "protected", "C": "private", "D": "任何类型的继承都不能使得派生类可以访问基类的 private 成员"}, "label": "ceval"}
{"question": "设有100个结点，用二分法查找时，最大比较次数是____。", "answer": null, "options": {"A": "25", "B": "50", "C": "10", "D": "7"}, "label": "ceval"}
{"question": "观察以下程序片段\nint a[5]={1,2,4,8,16};\nint*p=&a[0];\nint*q=&a[4];\ncout<<q-p<<endl;\n其输出为____", "answer": null, "options": {"A": "15", "B": "4", "C": "16", "D": "程序片段中存在语法错误"}, "label": "ceval"}
{"question": "循环队列的队头和队尾指针分别为front和rear,则判断循环队列为空的条件是____。", "answer": null, "options": {"A": "front==rear", "B": "front==0", "C": "rear==0", "D": "front=rear+1"}, "label": "ceval"}
{"question": "派生类的对象对它的基类成员中什么是可访问的____", "answer": null, "options": {"A": "公有继承的公有成员", "B": "公有继承的私有成员", "C": "公有继承的保护成员", "D": "私有继承的公有成员"}, "label": "ceval"}
{"question": "观察以下程序段\nstring a=\"abcd\";\nstring b=\"bcd\";\nif(a>b)cout<<\"a>b\"<<a.length()<<endl;\nelse cout<<\"a<b\"<<a.length()<<endl;\n那么程序的输出为____", "answer": null, "options": {"A": "a>b 4", "B": "a<b 4", "C": "a>b 5", "D": "a<b 5"}, "label": "ceval"}
{"question": "已知字符集{a，b，c，d，e，f，g，h}，若各字符的哈夫曼编码依次是0100，10，0000，0101，001，011，11，0001，则编码序列0100011001001011110101的译码结果是：____", "answer": null, "options": {"A": "a c g a b f h", "B": "a d b a g b b", "C": "a f b e a g d", "D": "a f e e f g d"}, "label": "ceval"}
{"question": "下列关于图的描述，错误的是____。", "answer": null, "options": {"A": "在一个无向图中，所有结点的度数之和等于所有边数的 2 倍", "B": "在一个有向图中，所以结点的入度或出度之和均等于所有边的数目", "C": "n 个结点的完全有向图包含n (n-1)条边", "D": "若要连通具有n 个结点的无向图，至少需要n 条边"}, "label": "ceval"}
{"question": "下列程序输出结果是：____\n#include<iostream>\n#include<iomanip>\nusing namespace std;\nint main(){\ncout<<\"hello\"<<setw(4)<<\"dear\"<<\"friends!\"<<endl;\ncout<<22<<\"\"<<hex<<33<<\"\"<<44<<endl;\nreturn 0;\n}", "answer": null, "options": {"A": "hellodearfriends!\n22 21 2c", "B": "hello dearfriends!\n22 21 2c", "C": "hello dear friends!\n22 21 44", "D": "hello dearfriends!\n22 21 44"}, "label": "ceval"}
{"question": "静态查找表与动态查找表二者的根本差别在于____。", "answer": null, "options": {"A": "它们的逻辑结构不一样", "B": "施加在其上的操作不同", "C": "包含的数据元素的类型不一样", "D": "存储实现不一样"}, "label": "ceval"}
{"question": "有如下程序段：\n#include<iostream>\nusing namespace std;\nclass A{\npublic:\n\tstatic int num;\n\tA(){num++;}\n};\nint A::num=0;\nint main(){\n\tA a,*b,d[2];\n\tcout<<A::num<<endl;\n\treturn 0;\n}\n执行上面的程序将输出____", "answer": null, "options": {"A": "0", "B": "1", "C": "3", "D": "4"}, "label": "ceval"}
{"question": "现有一棵无重复关键字的平衡二叉树(AVL树)，对其进行中序遍历可得到一个升序序列。下列关于该平衡二叉树的叙述中，正确的是____", "answer": null, "options": {"A": "根结点的度一定为 2", "B": "树中最小元素一定是叶结点", "C": "最后插入的元素一定是叶结点", "D": "树中最大元素一定无右子树"}, "label": "ceval"}
{"question": "在C++中，下列类的成员函数____属于纯虚函数。", "answer": null, "options": {"A": "void display();", "B": "Virtual void display();", "C": "Virtual void display()=0;", "D": "Virtual void display(){int a=0};"}, "label": "ceval"}
{"question": "设一组初始记录关键字序列为(50,40,95,20,15,70,60,45)，则以增量d=4的一趟希尔排序结束后前4条记录关键字为____", "answer": null, "options": {"A": "40,50,20,95", "B": "15,40,60,20", "C": "15,20,40,45", "D": "45,40,15,20"}, "label": "ceval"}
{"question": "下面叙述正确的是____", "answer": null, "options": {"A": "抽象基类中所有的virtual函数都必须声明为纯virtual函数", "B": "使用基类指针引用一个派生类的对象是非常危险的", "C": "如果基类申明了一个纯virtual函数， 派生类只有实现该函数才能成为具体类。", "D": "一个类中有virtual函数， 该类就成为抽象类。"}, "label": "ceval"}
{"question": "以下说法不正确的是____", "answer": null, "options": {"A": "静态成员函数可以调用静态成员函数；", "B": "静态成员函数可以调用非静态成员函数；", "C": "非静态成员函数可以调用静态成员函数；", "D": "非静态成员函数可以调用非静态成员函数。"}, "label": "ceval"}
{"question": "若平衡二叉树的高度为6，且所有非叶子结点的平衡因子均为-1，则该平衡二叉树的结点总数为：____", "answer": null, "options": {"A": "12", "B": "20", "C": "32", "D": "33"}, "label": "ceval"}
{"question": "语句ofstreamf(\"SALARY.DAT\",ios::appiios::binary);的功能是建立流对象f,试图打开文件SALARY.DAT并与之连接，并且____", "answer": null, "options": {"A": "若文件存在，将文件写指针定位于文件尾;若文件不存在，建立一个新文件", "B": "若文件存在，将其置为空文件;若文件不存在，打开失败", "C": "若文件存在，将文件写指针定位于文件首;若文件不存在，建立一个新文件", "D": "若文件存在，打开失败;若文件不存在，建立一个新文件"}, "label": "ceval"}
{"question": "以下程序段的时间复杂度为____。\nvoid main(){\nint n=10,x=n,y=0;\nwhile(x>=(y+1)*(y+1))\ny++;\n}", "answer": null, "options": {"A": "O( n^(1/2))", "B": "O(n)", "C": "O(1)", "D": "O(n^2)"}, "label": "ceval"}
{"question": "在____情况下适宜采用inline定义内联函数。", "answer": null, "options": {"A": "函数体含有循环语句", "B": "函数体含有递归语句", "C": "函数代码少、频繁调用", "D": "函数代码多、不常调用"}, "label": "ceval"}
{"question": "有如下定义语句：int a[]={1,2,3,4,5};则对语句int *p=a;正确的描述是____", "answer": null, "options": {"A": "语句int *p=a;定义不正确", "B": "语句int *p=a;初始化变量p,使其指向数组对象a的首元素", "C": "语句int *p=a;是把数组a的值赋给变量p", "D": "语句int *p=a;是把a[0]的值赋给变量p"}, "label": "ceval"}
{"question": "在双向循环链表中，在P指针所指向的结点前插入一个指针q所指向的新结点，其格改指针的操作是____备注：双向链表的结点结构为(prev,data,next).", "answer": null, "options": {"A": "p->prev=q;q->next=p;p->prev->next=q;q->prev =q;", "B": "p->prev=q;p->prev->next=q;q->next=p;q->prev=p->prev;", "C": "q->prev=p->prev;q->next=p;p->prev=q;p->prev =q", "D": "q->next=p;q->prev=p->prev;p->prev->next=q;p->prev =q;"}, "label": "ceval"}
{"question": "下面这段代码的运行结果为____\n#include<iostream>\nusing namespace std;\nclass A{\npublic:\nvoid f(){cout<<\"A::f\"<<endl;}\n};\nclass B:public A{\npublic:\nvoid f(){cout<<\"B::f\"<<endl;}\n};\nint main()\n{\n\tA *p=new B();\n\tp->f();\n\tdelete p;\n\treturn 0;\n}", "answer": null, "options": {"A": "A::f", "B": "B::f", "C": "A::f\\nB::f（\\n表示换行）", "D": "不产生输出"}, "label": "ceval"}
{"question": "对给定的关键字序列110，119，007，911，114，120，122进行基数排序，则第2趟分配收集后得到的关键字序列是____", "answer": null, "options": {"A": "007， 110， 119， 114， 911， 120， 122", "B": "007， 110， 119， 114， 911， 122， 120", "C": "007， 110， 911， 114， 119， 120， 122", "D": "110， 120， 911， 122， 114， 007， 119"}, "label": "ceval"}
{"question": "如果图用邻接表结构存储，则常见操作的算法时间复杂度____", "answer": null, "options": {"A": "只和顶点的个数有关", "B": "只和边的条数有关", "C": "和顶点的个数、 边的条数都可能有关", "D": "和两者都无关"}, "label": "ceval"}
{"question": "C++支持两种多态，包括编译时多态和运行时多态，编译时多态和运行时多态分别通过____来实现", "answer": null, "options": {"A": "重 载 和 虚 函数", "B": "重 载 和 重 载", "C": "虚 函 数 和 重 载", "D": "虚函数和虚函数"}, "label": "ceval"}
{"question": "下面关于B树和B+树的叙述中，不正确的是____", "answer": null, "options": {"A": "都是平衡的多叉树", "B": "都能有效地支持顺序检索", "C": "都可以用于文件的索引结构", "D": "都能有效地支持随机检索"}, "label": "ceval"}
{"question": "对于拷贝构造函数和赋值操作的关系，正确的描述是____", "answer": null, "options": {"A": "进行赋值操作时， 会调用类的构造函数。", "B": "当调用拷贝构造函数时， 类的对象正在被建立并被初始化。", "C": "拷贝构造函数和赋值操作是完全一样的操作", "D": "拷贝构造函数和赋值操作不能在同一个类中被同时定义"}, "label": "ceval"}
{"question": "树最适合用来表示____。", "answer": null, "options": {"A": "有序数据元素", "B": "无序数据元素", "C": "元素之间具有分支层次关系的数据", "D": "元素之间无联系的数"}, "label": "ceval"}
{"question": "下述对C++语言字符数组的描述中错误的是____", "answer": null, "options": {"A": "字符数组可以存放字符串", "B": "字符数组中的字符串可以整体输入、输出", "C": "可以在赋值语句中通过赋值运算符”=\"对字符数组整体赋值", "D": "不可以用关系运算符对字符数组中的字符串进行比较"}, "label": "ceval"}
{"question": "一个队列的入队序列是1,2,3,4，则队列的出队序列是____。", "answer": null, "options": {"A": "1,2,3,4", "B": "4,3,2,1", "C": "1,4,3,2", "D": "3,4,1,2"}, "label": "ceval"}
{"question": "阅读代码，下列说法错误的是：____\n #include <iostream> \n #include <string.h> \n using namespace std; \n class A { \n  int *m_arr; \n  int m_size; \n public: \n  A(int i):m_size(i) {\n   m_arr = new int[m_size]; \n   memset(m_arr, 0, m_size*sizeof(int)); \n  } \n  ~A() {\n   delete []m_arr; //(2)\n  } \n  void set(int index, int value) { \n   m_arr[index] = value; \n  } \n  void print() {\n   cout << \"m_arr: \";\n   for (int i = 0; i < m_size; ++ i) {\n    cout << \" \" << m_arr[i];\n   }\n   cout << endl;\n  }\n };\n int main() {\n  A a(5);\n  A b = a; //(1)\n  b.set(3, 10);\n  a.print(); //(3)\n  return 0;\n }", "answer": null, "options": {"A": "(3)执行完之后，该程序的输出为: m_arr: 0 0 0 10 0", "B": "程序中的语句(1)调用了编译器自动合成的拷贝构造函数", "C": "该程序可以正常执行，且程序的返回值为0", "D": "如果将程序中的语句(2)改成delete m_arr，则可能会出现内存泄漏"}, "label": "ceval"}
{"question": "下面的叙述中____是正确的。", "answer": null, "options": {"A": "若有一个结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子", "B": "若有一个结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子", "C": "若有一个叶子结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是", "D": "若有一个叶子结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是"}, "label": "ceval"}
{"question": "对于std::string和std::vector<char>定义的字符串str，以下选项正确的是：____", "answer": null, "options": {"A": "都可以使用str.length();获得字符串长度", "B": "都可以使用for(char c: str)遍历字符串中的所有字符", "C": "都可以使用cin>>str;从标准输入输入字符串", "D": "都可以使用str+=\"abc\";向字符串尾部添加字符"}, "label": "ceval"}
{"question": "设入栈顺序为A,B,C,D,E,则出栈序列不可能是____", "answer": null, "options": {"A": "EDCBA", "B": "ABCDE", "C": "ADEBC", "D": "ABDEC"}, "label": "ceval"}
{"question": "在无向图中定义顶点vi与vj之间的路径为从vi到vj的一个____。", "answer": null, "options": {"A": "顶点序列", "B": "边序列", "C": "权值总和", "D": "边的条数"}, "label": "ceval"}
{"question": "下面程序的运行结果是____\n#include<iostream.h>\nvoid main()\n{\nint num=1;\nint& ref=num;\nref=ref+2;\ncout<<num;\nnum=num+3;\ncout<<ref<<endl;\n}", "answer": null, "options": {"A": "13", "B": "16", "C": "36", "D": "33"}, "label": "ceval"}
{"question": "判定一个顺序栈s(栈空间大小为n)为空的条件是____。", "answer": null, "options": {"A": "S->top==0", "B": "S->top!=0", "C": "S->top==n", "D": "S->top!=n"}, "label": "ceval"}
{"question": "在一个单链表中，删除P指向的结点后的结点s,则执行____", "answer": null, "options": {"A": "delete s;", "B": "P->next=s-next;", "C": "P->next=NULL;", "D": "P->next=S->next; delete s;"}, "label": "ceval"}
{"question": "若已知char str[10];有语句cin>>str; 当输入为：This is a program,所得到的结果是str=____", "answer": null, "options": {"A": "This is a program", "B": "T", "C": "This", "D": "This is a"}, "label": "ceval"}
{"question": "当利用大小为n的数组顺序存储一个栈时，假定用top==n表示栈空，则向这个栈插入一个元素时,首先应执行____语句修改top指针。", "answer": null, "options": {"A": "top++", "B": "top--", "C": "top=0", "D": "top"}, "label": "ceval"}
{"question": "下述文件中适合于磁带存储的是____", "answer": null, "options": {"A": "顺序文件", "B": "索引文件", "C": "散列文件", "D": "多关键字文件"}, "label": "ceval"}
{"question": "一棵深度为10的完全二叉树，从根结点开始，对所有结点按照层次依次编号:0,1,2…，则编号为18的结点，其父结点编号为____", "answer": null, "options": {"A": "10", "B": "9", "C": "8", "D": "5"}, "label": "ceval"}
{"question": "下列程序输出结果是：____\n#include<iostream>\nusing namespace std;\nclass AA{\npublic:\nvoid fun(){cout<<\"AA\";}\n};\nclass BB:public AA{\npublic:\nBB(){cout<<\"BB\";}\n};\nclass CC:public BB{\nvoid fun(){\nBB::fun();\ncout<<\"CC\";\n}\n};\nint main(int argc,const char*argv[]){\nAA aa,*p;\nBB bb;\nCC cc;\np=&cc;\np->fun();\nreturn 0;\n}", "answer": null, "options": {"A": "BBBBAA", "B": "BBBBCC", "C": "BBBBAACC", "D": "BBCC"}, "label": "ceval"}
{"question": "在c++中，下列关于友元函数和成员函数的区别，____是正确的。", "answer": null, "options": {"A": "都具有 this 指针", "B": "友员函数不具有 this 指针，而成员函数则具有。", "C": "友员函数的定义和成员函数的定义相同，都需要类名加上作用域算符::为前纵", "D": "友员函数的定义与成员函数一样需要以类名加上作用域运算符::为前纵"}, "label": "ceval"}
{"question": "由权值分别为11,8,6,2,5的叶子结点生成一棵哈夫曼树，它的带权路径长度为____", "answer": null, "options": {"A": "24", "B": "73", "C": "48", "D": "53"}, "label": "ceval"}
{"question": "若一个栈的输入序列为1,2,3,…,n，输出序列的第一个元素是i，则第j个输出元素是____。", "answer": null, "options": {"A": "i-j-1", "B": "i-j", "C": "j-i+1", "D": "不确定的"}, "label": "ceval"}
{"question": "以下正确的描述是____", "answer": null, "options": {"A": "预处理指令只能位于 C 源程序文件的首部。", "B": "凡是 C 源程序中行首以“#” 标识的控制行都是预处理指令。", "C": "C +语言的编译预处理就是对源程序进行初步的语法检查。", "D": "C 语言的预处理功能是指完成宏替换和包含文件的调用。"}, "label": "ceval"}
{"question": "定义如下的Test类，下列说法正确的是____ \nclass Test{\n\t\tconst int member;\n\t\tfloat another_member;\n\tpublic:\n\t\tTest(int mem):member(mem){another_member=1.0;}\n\t\tint MyMember()const{return member;}\n\t\tfloat MyAnotherMember(){return another_member;}\n\t}", "answer": null, "options": {"A": "member的值在不同的Test对象中可以不同", "B": "初始化数据成员member时，可以采用类似于another_member的初始化方式，在构造函数的函数体中赋值", "C": "成员函数MyMember的函数体内可以增加语句，修改another_member的值", "D": "定义一个Test类的常量对象，其可以调用MyMember和MyAnotherMember两个成员函数"}, "label": "ceval"}
{"question": "设输入序列为1,2,3,4,5,6,则通过栈的作用后可以得到的输出序列为____", "answer": null, "options": {"A": "5, 3, 4, 6, 1, 2", "B": "3， 2， 5， 6， 4， 1", "C": "3, 1, 2, 5, 4, 6", "D": "1， 5， 4， 6, 2， 3"}, "label": "ceval"}
{"question": "一个非空广义表的表头____。", "answer": null, "options": {"A": "不可能是子表", "B": "只能是子表", "C": "只能是原子", "D": "可以是子表或原子"}, "label": "ceval"}
{"question": "以下类定义不正确的是____", "answer": null, "options": {"A": "class A {   Public:  void Func(int x){…};int Func(int x){…}; };", "B": "class B {public:void Func( int x){…};void Func( double x){…};};", "C": "class C {public: void Func(int x,int y){…};void Func( int x){…}; };", "D": "class D {public:int  Func( int x){…};char*  Func( char x){…};};"}, "label": "ceval"}
{"question": "二叉查找树的查找时间复杂度最差为____", "answer": null, "options": {"A": "O(n^2)", "B": "O(nlogn)", "C": "0(n)", "D": "0(log_2n)"}, "label": "ceval"}
{"question": "如果类A被说明成类B的友元，则____", "answer": null, "options": {"A": "类 A 的成员即类 B 的成员", "B": "类 B 的成员即类 A 的成员", "C": "类 A 的成员函数不得访问类 B 的成员", "D": "类 B 不一定是类 A 的友元"}, "label": "ceval"}
{"question": "若完全二叉树的结点总数为1001，则度为1的结点有____个。", "answer": null, "options": {"A": "0", "B": "1", "C": "500", "D": "501"}, "label": "ceval"}
{"question": "后缀表达式823+-62/-的计算结果是____", "answer": null, "options": {"A": "-1", "B": "1", "C": "0", "D": "2"}, "label": "ceval"}
{"question": "设一组初始关键字记录关键字为(20,15,14,18,21,36,40,10)，则以20为基准记录的一趟快速排序结束后的结果为____", "answer": null, "options": {"A": "10,15,14,18,20,36,40,21", "B": "10,15,14,18,20,40,36,21", "C": "10,15,14,20,18,40,36,21", "D": "15,10,14,18,20,36,40,21"}, "label": "ceval"}
{"question": "在C++中,____一定不能创建类的对象和实例.", "answer": null, "options": {"A": "虚基类", "B": "抽象类", "C": "基类", "D": "派生类"}, "label": "ceval"}
{"question": "下列输出字符'A'的方法中，错误的是____", "answer": null, "options": {"A": "char A = 'A'; cout<<A;", "B": "cout<<'A';", "C": "cout<<put('A');", "D": "cout.put('A');"}, "label": "ceval"}
{"question": "现有一个实现数据结构“栈”的需求，程序员X对栈的设计进行了如下思考，其中你认为有问题的是：____", "answer": null, "options": {"A": "可以利用C++ STL中的vector，使用适配器模式将其适配为符合栈的抽象接口的类", "B": "对于栈中元素的内存分配和释放，可以使用策略模式来实现不同内存分配/释放算法", "C": "如果使用装饰器模式对一个栈数据结构进行多次功能扩展，就不会出现多重嵌套的问题", "D": "可以使用代理/委托模式设计智能指针，对栈中元素进行内存分配和释放"}, "label": "ceval"}
{"question": "设计一个判别表达式中左右括号是否配对出现的算法，采用____数据结构最佳。", "answer": null, "options": {"A": "线性表的顺序存储结构", "B": "队列", "C": "栈", "D": "线性表的链式存储结构"}, "label": "ceval"}
{"question": "通过____调用虚函数时，采用动态束定。", "answer": null, "options": {"A": "对象指针", "B": "对象名", "C": "成员名限定", "D": "派生类名"}, "label": "ceval"}
{"question": "一组纪录的关键字序列为(33,66,43,25,27,71)，为排序非递减序列利用堆排序的方法建立的初始堆为____", "answer": null, "options": {"A": "(66,33,43,25,27,71)", "B": "(71,66,43,33,27,25)", "C": "(71,66,43,25,27,33)", "D": "(71,43,66,27,33,25)"}, "label": "ceval"}
{"question": "在类的说明符中，被指定为私有的数据可以被以下____访问。", "answer": null, "options": {"A": "程序中的任何函数", "B": "其他类的成员函数", "C": "类中的成员函数", "D": "派生类中的成员函数"}, "label": "ceval"}
{"question": "内排和外排的不同在于____", "answer": null, "options": {"A": "内排数据元素的类型简单，外排数据类型复杂", "B": "内排数据元素在内存中能全部放下，外排不能，一部分要存在外存储器上", "C": "内排数据存储用顺序结构，外排数据存储用链式结构", "D": "内排是稳定排序，外排是不稳定排序"}, "label": "ceval"}
{"question": "设某散列表的长度为100,散列函数H(k)=k%P,则P通常情况下最好选择____", "answer": null, "options": {"A": "99", "B": "97", "C": "91", "D": "93"}, "label": "ceval"}
{"question": "图的邻接矩阵表示法适用于表示____", "answer": null, "options": {"A": "无向图", "B": "有向图", "C": "稠密图", "D": "稀疏图"}, "label": "ceval"}
{"question": "有如下程序段：\n#include<iostream>\nusing namespace std;\nclass BASE{\n\tchar c;\npublic:\n\tBASE(char n):c(n){}\n\tvirtual~BASE(){cout<<c;}\n};\nclass DERIVED:public BASE{\n\tchar c;\npublic:\n\tDERIVED(char n):BASE(n+1),c(n){}\n\t~DERIVED(){cout<<c;}\n};\n\nint main()\n{\n\tDERIVED('X');\n\treturn 0;\n}\n执行上面的程序将输出____", "answer": null, "options": {"A": "XY", "B": "YX", "C": "X", "D": "Y"}, "label": "ceval"}
{"question": "在类中说明的成员可以使用关键字____进行修饰。", "answer": null, "options": {"A": "private", "B": "extern", "C": "auto", "D": "register"}, "label": "ceval"}
{"question": "表达式a*(b+c)-d的前缀表达式是____", "answer": null, "options": {"A": "abcdd+-", "B": "-*a+bcd", "C": "abc*+d-", "D": "-+*abcd"}, "label": "ceval"}
{"question": "从空栈开始依次将字符A、B、C、D、E入栈，在所有可能的出栈序列中，最后一个出栈元素是C的序列的个数是____", "answer": null, "options": {"A": "5", "B": "1", "C": "4", "D": "3"}, "label": "ceval"}
{"question": "结构类型Date作为函数的参数，如果该参数在函数中只读不写,则以下参数说明中最好的是____", "answer": null, "options": {"A": "const Date &d", "B": "const Date d", "C": "Date &d", "D": "Date d"}, "label": "ceval"}
{"question": "以下序列不是堆的是____。", "answer": null, "options": {"A": "100,85,98,77,80,60,82,40,20,10,66", "B": "100,98,85,80,77,82,66,60,40,20,10", "C": "10,20,40,60,66,77,80,82,85,98,100", "D": "100,85,40,77,80,60,66,98,82,10,20"}, "label": "ceval"}
{"question": "下列说法正确的是____", "answer": null, "options": {"A": "非常量左值引用与常量左值引用既可以绑定左值，也可以绑定右值", "B": "int y=2,z=3;int &&w = y * z;不能够正常运行", "C": "int y=3,z=3;const int &w = y * z;能够正常运行", "D": "在函数中的临时左值引用可以先定义，再赋值"}, "label": "ceval"}
{"question": "链表结点的结构类型为struct linkRec{int data;linkRec *next;},如果指针rear指向尾结点，将节点p链入表尾，并将p作为新的表尾可用语句____", "answer": null, "options": {"A": "rear->next=p->next;rear=p;", "B": "rear->next=p;rear=p;", "C": "rear->next=rear;p->next=p;", "D": "(*rear ).next=rear;(*p).next=p;"}, "label": "ceval"}
{"question": "设一个链表最常用的操作是在末尾插入结点和删除尾结点，则选用____最节省时间。", "answer": null, "options": {"A": "单链表", "B": "单循环链表", "C": "带尾指针的单循环链表", "D": "带头结点的双循环链表"}, "label": "ceval"}
{"question": "下列不属于责任链模式的优点的是____", "answer": null, "options": {"A": "提高系统性能；", "B": "便于增加新的处理请求类；", "C": "降低耦合度；", "D": "简化对象。"}, "label": "ceval"}
{"question": "若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3。当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为____。", "answer": null, "options": {"A": "1 和 5", "B": "2 和 4", "C": "4 和 2", "D": "5 和 1"}, "label": "ceval"}
{"question": "char s, *p=&s,&ch=s; 则等价于 s='#'的语句为____", "answer": null, "options": {"A": "p='#'", "B": "*p='#'", "C": "*ch='#'", "D": "&dr='#'"}, "label": "ceval"}
{"question": "定义如下所示的Base类和Derive类，下列说法错误的是：____\n #include <iostream>\n using namespace std;\n class Base {\n  int data;\n public:\n  Base() : data(0) { cout << \"Base::Base(\" << data << \")\\n\"; }\n  Base(int i) : data(i) { cout << \"Base::Base(\" << i << \")\\n\"; }\n };\n class Derive : public Base {\n  int data{2018};\n public: \n  Derive() {}\n  Derive(int i) : Base(i) {}\n  void print() { cout << \"data = \" << data << endl; }\n };\n int main() {\n  Derive obj1;\n  Derive obj2(2019);\n  obj1.print();\n  obj2.print();\n  return 0;\n }", "answer": null, "options": {"A": "Derive类的默认构造函数没有显式调用Base类的构造函数，此时编译器会自动调用Base类的默认构造函数", "B": "Derive类的普通构造函数可以在初始化列表中显式调用Base类的普通构造函数", "C": "该程序的输出为Base::Base(0)\\nBase::Base(2019)\\ndata = 2018\\ndata = 2019\\n", "D": "obj1析构时先执行Derive类的析构函数，再执行Base类的析构函数"}, "label": "ceval"}
{"question": "类CStudent的拷贝构造函数的声明语句为____", "answer": null, "options": {"A": "CStudent &CStudent (const CStudent other)", "B": "CStudent CStudent(const CStudent other)", "C": "CStudent (CStudent *other)", "D": "CStudent (const CStudent &other)"}, "label": "ceval"}
{"question": "下列说法错误的是____", "answer": null, "options": {"A": "求最短路径的Dijkstra算法中边的权值不可以为负", "B": "Dijkstra算法允许图中有回路", "C": "Floyd算法中边的权值不可以为负", "D": "深度优先搜索算法可用于判断有向图中是否存在回路"}, "label": "ceval"}
{"question": "下面的循环体执行的次数与其它不同的是____", "answer": null, "options": {"A": "i=0;while(++i<100){cout<i<\" \";}", "B": "for(i=0;i<100;++i){cout<<i<<” \";}", "C": "for(i=100;i>=1;--i){cout<i<\" \";}", "D": "i=0;while(i++<100){cout<<i<<\" \";}"}, "label": "ceval"}
{"question": "在按层次遍历二叉树的算法中，需要借助的辅助数据结构是____", "answer": null, "options": {"A": "队列", "B": "栈", "C": "线性表", "D": "有序表"}, "label": "ceval"}
{"question": "类模板定义如下：\ntemplate<classT,int low,int high>\nclass Array{....};\n对该类模板实例化正确的是____", "answer": null, "options": {"A": "Array<float,0,20> x;", "B": "Array<int,int,int> x;", "C": "template<int,0,20> x;", "D": "Array<int,0,int> x;"}, "label": "ceval"}
{"question": "采用稀疏矩阵的三元组表形式进行压缩存储，若要完成对三元组表进行转置，只要将行和列对换，这种说法____。", "answer": null, "options": {"A": "正确", "B": "错误", "C": "无法确定", "D": "以上均不对"}, "label": "ceval"}
{"question": "Sample是用户定义的某个类，obj是Sample类的对象，p是Sample类的指针，则执行语句p=new Sample时会调用____", "answer": null, "options": {"A": "Sample 类的构造函数", "B": "Sample 类的析构函数", "C": "Sample 类的赋值运算符重载函数", "D": "Sample 类的拷贝构造函数"}, "label": "ceval"}
{"question": "在C++中，可以重载的运算符有____。", "answer": null, "options": {"A": "sizeof()", "B": "::", "C": ".*", "D": "++"}, "label": "ceval"}
{"question": "#include<iostream.h>\n{\n//This is my first program\ncout<<\"My first program in C++\";\n}\n这段C++程序的输出是____。", "answer": null, "options": {"A": "My first program in C++", "B": "This is my first program", "C": "My first Program in C", "D": "None of the above"}, "label": "ceval"}
{"question": "用某种排序方法对关键字序列(25,84,21,47,15,27,68,35,20)进行排序时，序列的变化情况如下：\n20,15,21,25,47,27,68,35,84\n15,20,21,25,35,27,47,68,84\n15,20,21,25,27,35,47,68,84\n则所采用的排序方法是____", "answer": null, "options": {"A": "选择排序", "B": "希尔排序", "C": "归并排序", "D": "快速排序"}, "label": "ceval"}
{"question": "对10TB的数据文件进行排序，应使用的方法是____", "answer": null, "options": {"A": "希尔排序", "B": "堆排序", "C": "快速排序", "D": "归并排序"}, "label": "ceval"}
{"question": "快速排序在最坏情况下的时间复杂度为____", "answer": null, "options": {"A": "O(log2n)", "B": "O(nlog2n)", "C": "O(n)", "D": "O(n^2)"}, "label": "ceval"}
{"question": "若将关键字1，2，3，4，5，6，7依次插入到初始为空的平衡二叉树T中，则T中平衡因子为0的非叶子结点的个数是____", "answer": null, "options": {"A": "0", "B": "1", "C": "2", "D": "3"}, "label": "ceval"}
{"question": "对初始数据序列｛8，3，9，11，2，1，4，7，5，10，6｝进行希尔排序。若第一趟排序结果为｛1，3，7，5，2，6，4，9，11，10，8｝，第二趟排序结果为｛1，2，6，4，3，7，5，8，11，10，9｝，则两趟排序采用的增量分别是____。", "answer": null, "options": {"A": "3，1", "B": "3，2", "C": "5，2", "D": "5，3"}, "label": "ceval"}
{"question": "函数f声明为void f(int *n),在主程序中定义变量m为int m=10,则下面调用正确的是____", "answer": null, "options": {"A": "f(*m)", "B": "f(&m)", "C": "f(m)", "D": "f(10+m)"}, "label": "ceval"}
{"question": "下列关于无向连通图特性的叙述中，正确的是____。\n（1）所有顶点的度数之和为偶数。\n（2）边数比顶点个数减1要大。\n（3）至少有1个顶点的度为1。", "answer": null, "options": {"A": "只有（1）", "B": "只有（2）", "C": "（1）和（2）", "D": "（1）和（3）"}, "label": "ceval"}
{"question": "int a=10,b=11,c=12,x=(a+b)<c&&(b=7):则此时b的值是____", "answer": null, "options": {"A": "11", "B": "0", "C": "7", "D": "1"}, "label": "ceval"}
{"question": "下列排序算法中，____算法可能会出现下面情况：初始数据有序时，花费时间反而更多。", "answer": null, "options": {"A": "堆排序", "B": "冒泡排序", "C": "快速排序", "D": "希尔排序"}, "label": "ceval"}
{"question": "以下说法正确的是____。", "answer": null, "options": {"A": "数据元素是数据的最小单位", "B": "数据项是数据的基本单位", "C": "数据结构是带有结构的各数据项的集合", "D": "一些表面上很不相同的数据可以有相同的逻辑结构"}, "label": "ceval"}
{"question": "已知各变量的类型说明如下：\nint a=0;\ndouble x=1.42;\nchar ch;\n则以下不符合C+语言语法的表达式是____", "answer": null, "options": {"A": "a+=0x123fd", "B": "x=12e-8", "C": "ch=\"y\"", "D": "ch='\\0'"}, "label": "ceval"}
{"question": "在C++中,运算符new的作用是____", "answer": null, "options": {"A": "创建名为 new 的对象", "B": "获取一个新类的内存", "C": "返回指向所创建对象的指针，并为创建的对象分配内存空间", "D": "返回为所创建的对象分配内存的大小"}, "label": "ceval"}
{"question": "以下关于单例模式说法不正确的是：____", "answer": null, "options": {"A": "单例模式只需要显式删除构造函数与拷贝构造函数即可保证只能构造一份类的实例", "B": "CRPT模式与虚函数不同，实现了编译时多态", "C": "静态虚函数可以实现和单例模式类似的“全局访问”功能", "D": "我们可以使用惰性初始化，返回单例实例的引用。但这种方法仍然存在用户自行delete所生成单例实例，引发错误的可能"}, "label": "ceval"}
{"question": "判断一个有向图是否存在回路，除了可以利用拓扑排序方法外，还可以利用____。", "answer": null, "options": {"A": "求关键路径的方法", "B": "求最短路径的Dijkstra方法", "C": "深度优先遍历算法", "D": "广度优先遍历算法"}, "label": "ceval"}
{"question": "在含n个顶点和e条边的无向图的邻接矩阵中，空元素的个数为____", "answer": null, "options": {"A": "e", "B": "2e", "C": "n^2-e", "D": "n^2-2e"}, "label": "ceval"}
{"question": "B+树不同于B树的特点之一是____", "answer": null, "options": {"A": "能支持顺序查找", "B": "结点中含有关键字", "C": "根结点至少有两个分支", "D": "不适合外部文件建立索引用"}, "label": "ceval"}
{"question": "以下说法不正确的是____", "answer": null, "options": {"A": "类的静态成员（数据、函数）既可以通过对象来访问，也可以通过类名来访问", "B": "非静态成员函数可以调用静态成员函数", "C": "静态数据成员可以在.h文件中声明，在.cpp文件中初始化", "D": "常量静态数据成员必须在类外进行初始化"}, "label": "ceval"}
{"question": "如果A是已经定义好的一个类，函数f的原型为A f()，r2是A类的一个对象，在函数f中执行return r2时，系统将自动调用____", "answer": null, "options": {"A": "缺省的构造函数", "B": "拷贝构造函数", "C": "赋值运算符重载函数", "D": "不调用任何函数"}, "label": "ceval"}
{"question": "在int a=3,*p=&a;中，*p的值是____。", "answer": null, "options": {"A": "变量 a 的地址值", "B": "无意义", "C": "变量 p 的地址值", "D": "3"}, "label": "ceval"}
{"question": "比较次数与排序的初始状态无关的排序方法是____", "answer": null, "options": {"A": "直接插入排序", "B": "起泡排序", "C": "快速排序", "D": "简单选择排序"}, "label": "ceval"}
{"question": "线性表采用链式存储时，结点的存储地址____", "answer": null, "options": {"A": "必须是不连续的", "B": "连续与否均可", "C": "必须是连续的", "D": "和头结点的存储地址相连续"}, "label": "ceval"}
{"question": "设栈S和队列Q的初始状态为空，元素a,b,c,d,e,f依次通过栈S,—个元素出站后即进队列Q。若6个元岽出队的序列为b,d,c,f,e,a,则栈的容量至少应为____", "answer": null, "options": {"A": "6", "B": "4", "C": "3", "D": "2"}, "label": "ceval"}
{"question": "由两个栈共享一个向量空间的好处是____", "answer": null, "options": {"A": "减少存取时间，降低下滥发生的机率", "B": "节省存储空间，降低上溢发生的机率", "C": "减少存取时间，降低上溢发生的机率", "D": "节省存储空间。降低下溢发生的机率"}, "label": "ceval"}
{"question": "若表达式y*x++中，“*”是作为成员函数重载的运算符，“++”是作为友元函数重载的运算符，采用运算符函数调用格式，该表达式还可以表达为____", "answer": null, "options": {"A": "x.operator++(0).operator*(y)", "B": "operator*(x.operator++(0),y)", "C": "y.operator*(operator++(x,0))", "D": "operator*(operator++(x,0),y)"}, "label": "ceval"}
{"question": "某二叉树的前序遍历序列和后序遍历序列正好相反，则该二叉树一定是____的二叉树。", "answer": null, "options": {"A": "空或只有一个结点", "B": "叶子结点数至多为1", "C": "任一结点无左儿子", "D": "任一结点无右儿子"}, "label": "ceval"}
{"question": "一个具有N个顶点的连通无向图的最小生成树中有____条边", "answer": null, "options": {"A": "N-1", "B": "N", "C": "N/2", "D": "N+1"}, "label": "ceval"}
{"question": "根据下面程序，判断下列说法不正确的是：\n\t#include<iostream>\n\tusing namespace std;\n\tclass X{\n\tprivate:\n\t\tint data=0;\n\t\tfriend class Y;\n\t\tfriend void print(X&x);\n\t};\n\tclass X_Son:public X{\n\tprivate:\n\t\tint data=1;\n\t};\n\tclass Y{\n\tprivate:\n\t\tint data=2;\n\t\tfriend class Z;\n\t};\n\tclass Z{\n\tprivate:\n\t\tint data=3;\n\t};\n\tvoid print(X&x){\n\t\tcout<<x.data<<endl;\n\t}____", "answer": null, "options": {"A": "print是X的友元函数", "B": "Z是Y的友元类", "C": "Y是X的友元类", "D": "Z是X的友元类"}, "label": "ceval"}
{"question": "#include<iostream.h>\nclass X\n{\nprivate:\nint num;\npublic:\nX(int intx){num=intx;}\nX(X &Y)\n{\nnum=++Y.num;\n}\nvoid disp(){cout<<num<<\"\";}\n};\nvoid main()\n{\nX a(10);\nX b(a);\na.disp();\nb.disp();\n}在\nC++中，以上程序的运行结果为____。", "answer": null, "options": {"A": "10 10", "B": "10 11", "C": "11 11", "D": "11 10"}, "label": "ceval"}
{"question": "可以用p.a的形式访问派生类对象p的基类成员a,其中a是____", "answer": null, "options": {"A": "私有继承的公有成员", "B": "公有继承的私有成员", "C": "公有继承的保护成员", "D": "公有继承的公有成员"}, "label": "ceval"}
{"question": "表达式a*(b+c)-d的后缀表达式是____。", "answer": null, "options": {"A": "abcd+-", "B": "abc+*d-", "C": "abc*+d-", "D": "-+*abcd"}, "label": "ceval"}
{"question": "#include<iostream.h>\nclass A\n{\npublic:\nA(){}\n~A(){cout<<\"A destroy\";}\n};\nclass B:public A\n{public:\nB():A(){}\n~B(){cout<<\"B destroy\";}\n};\nvoid main(){B obj;}\n上面的C++程序运行的结果是____。", "answer": null, "options": {"A": "B destroy A destroy", "B": "A destroy B destroy", "C": "A destroy", "D": "B destroy"}, "label": "ceval"}
{"question": "在任意一棵非空二叉查找树T1中，删除某结点v之后形成二叉查找树T2，再将v插入T2形成二叉查找树T3。下列关于T1与T3的叙述中，正确的是____\nI.若v是T1的叶结点，则T1与T3不同\nII.若v是T1的叶结点，则T1与T3相同\nIII.若v不是T1的叶结点，则T1与T3不同\nIV.若v不是T1的叶结点，则T1与T3相同", "answer": null, "options": {"A": "仅 I、III", "B": "仅 I、IV", "C": "仅 II、III", "D": "仅 II、IV"}, "label": "ceval"}
{"question": "下列二叉树哪种满足以下性质:从任意一个结点出发到根的路径上所经过的结点序列按其关键字有序____", "answer": null, "options": {"A": "二叉查找树", "B": "哈夫曼树", "C": "伸展树", "D": "堆"}, "label": "ceval"}
{"question": "下列关于静态成员说法正确的是____", "answer": null, "options": {"A": "同一个类的所有类对象，共享该类的静态数据成员，即所有对象中的该数据成员存储在同一内存位置", "B": "类的常量静态成员数据只能在类外进行初始化", "C": "类的静态成员数据只能通过类名来访问", "D": "静态成员函数属于整个类，在第一个类实例化对象创建的时候分配它的内存空间"}, "label": "ceval"}
{"question": "无向图G有22条边，度为5的顶点有3个，度为3的顶点有5个，其余都是度为2的顶点，则图G最多有多少个顶点？____", "answer": null, "options": {"A": "11", "B": "12", "C": "15", "D": "16"}, "label": "ceval"}
{"question": "如果A是已经定义好的一个类，有如下定义语句：A*p[5];则当类对象数组指针p离开它的作用域时，系统自动调用类A的析构函数____次", "answer": null, "options": {"A": "5", "B": "1", "C": "0", "D": "10"}, "label": "ceval"}
